<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>零零碎碎</title>
      <link href="/2024/04/14/%E5%85%AB%E8%82%A1vue/"/>
      <url>/2024/04/14/%E5%85%AB%E8%82%A1vue/</url>
      
        <content type="html"><![CDATA[<h3 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h3><p>vue数据双向绑定是通过<code>数据劫持</code>结合<code>发布者-订阅者模式</code>(观察者模式)的方式来实现的</p><p>我们已经知道实现数据的双向绑定，首先要对<code>数据进行劫持监听</code>，所以我们需要设置一个<code>监听器</code>Observer，用来<code>监听所有属性</code>。如果<code>属性</code>发生<code>变化</code>了，就需要<code>告诉订阅者</code>Watcher看<code>是否需要更新</code>。因为订阅者是有很多个，所以我们需要有一个<code>消息订阅器Dep</code>来专门<code>收集这些订阅者</code>，然后在<code>监听器</code>Observer和<code>订阅者</code>Watcher之间进行<code>统一管理</code>的。接着，我们还需要有一个<code>指令解析器</code>Compile，对<code>每个节点元素</code>进行<code>扫描和解析</code>，将<code>相关指令</code>（如v-model，v-on）对应<code>初始化成一个订阅者</code>Watcher，并<code>替换模板数据或者绑定相应的函数</code>，此时<code>当订阅者Watcher接收到相应属性的变化</code>，就会<code>执行对应的更新函数</code>，从而<code>更新视图</code>。</p><h3 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h3><h3 id="组件间传递数据"><a href="#组件间传递数据" class="headerlink" title="组件间传递数据"></a>组件间传递数据</h3><ol><li>父组件向子组件传递数据，使用props属性；子组件向父组件中传递数据，在子组件中使用$emit派发事件，父组件中使用v-on监听事件；<br>缺点：组件嵌套层次多的话，传递数据比较麻烦。</li><li>祖先组件通过依赖注入(inject &#x2F; provide)的方式，向其所有子孙后代传递数据；<br>缺点：无法监听数据修改的来源，不支持响应式。</li><li>通过属性$root &#x2F; $parent &#x2F; $children &#x2F;ref，访问根组件、父级组件、子组件中的数据；<br>缺点：要求组件之间要有传递性。</li><li>通过事件总线(event bus)的方式，可以实现任意两个组件间进行数据传递；<br>缺点：不支持响应式，这个概念是vue1.0版本中的，现在已经废弃。</li><li>通过 VueJs 的状态管理模式 Vuex，实现多个组件进行数据共享，推荐使用这种方式进行项目中各组件间的数据传递。</li></ol><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>简单总结： </p><p>（1）全局函数中的this指向window</p><p>（2）对象中的方法（函数）中的this，指向对象，理解：obj.m&#x3D;function(){}，m和fn等价，因此调用m也相当于调用fn，原理同3）</p><p>（3）构造函数中的this指向调用该构造函数的实例对象</p><p>（4）特殊this指向:</p><p>箭头函数没有绑定this，this继承自外围作用域，理解：查看上一层级的函数的this的指向，继承它！！</p><p>（5）绑定this指向：apply，call，bind绑定的对象</p><h3 id="接下来用实例来介绍下各种this问题"><a href="#接下来用实例来介绍下各种this问题" class="headerlink" title="接下来用实例来介绍下各种this问题"></a>接下来用实例来介绍下各种this问题</h3><ol><li><p>全局环境下，this 始终指向全局对象（window）, 无论是否严格模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(this.document === document); // true</span><br><span class="line">// 在浏览器中，全局对象为 window 对象：</span><br><span class="line">console.log(this === window); // true</span><br><span class="line">this.a = 3;</span><br><span class="line">console.log(window.a); // 3</span><br></pre></td></tr></table></figure></li><li><p>函数直接调用，普通函数内部的this分两种情况，严格模式和非严格模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   //严格模式下， this为undefined</span><br><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; // 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line">f2() === undefined; // true</span><br><span class="line">   //而非严格模式下，this 默认指向全局对象window</span><br><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line">f1() === window; // true</span><br></pre></td></tr></table></figure></li><li><p>对象中的this，对象内部方法的this指向调用这些方法的对象</p><p>&#x2F;&#x2F;函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。<br>&#x2F;&#x2F;多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，其内部对象调<br>&#x2F;&#x2F;用方法的this指向内部对象， 而非window）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//例一：</span><br><span class="line">var obj = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.f());  //37</span><br><span class="line">var a = obj.f;</span><br><span class="line">console.log(a());  //undefined</span><br><span class="line"></span><br><span class="line">var obj = &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">  return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.f = independent;</span><br><span class="line"></span><br><span class="line">console.log(obj.f()); //37</span><br><span class="line"></span><br><span class="line">//例二：</span><br><span class="line">obj.b = &#123;</span><br><span class="line">  num: independent,</span><br><span class="line">  prop: 42</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.b.num()); //42</span><br></pre></td></tr></table></figure></li><li><p>原型链中this，原型链中的方法的this仍然指向调用它的对象</p></li></ol>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. var obj = &#123;</span><br><span class="line">     f : function()&#123; </span><br><span class="line">       return this.a + this.b; </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   var p = Object.create(obj);</span><br><span class="line">   p.a = 1;</span><br><span class="line">   p.b = 4;</span><br><span class="line"></span><br><span class="line">   console.log(p.f()); // 5</span><br><span class="line">   //在p中没有属性f，当执行p.f()时，会查找p的原型链，找到 f 函数并执行，但这与函数内部this指向对象 //p 没有任何关系，只需记住谁调用指向谁。</span><br><span class="line"></span><br><span class="line">//以上对于函数作为getter &amp; setter 调用时同样适用。</span><br></pre></td></tr></table></figure><ol start="5"><li>构造函数中this，构造函数中的this与被创建的新对象绑定</li></ol><p>注意：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。<br>6. call &amp; apply</p><p>当函数通过Function对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的this值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。<br>7. bind 方法</p><p>bind方法在ES5引入， 在Function的原型链上， Function.prototype.bind。通过bind方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。</p><ol start="8"><li>DOM事件处理函数，当函数被当做监听事件处理函数时， 其 this 指向触发该事件的元素 （针对于addEventListener事件）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被调用时，将关联的元素变成蓝色</span><br><span class="line">  function bluify(e)&#123;</span><br><span class="line">    console.log(this);//在控制台打印出所点击元素</span><br><span class="line">    e.stopPropagation();//阻止时间冒泡</span><br><span class="line">    e.preventDefault();//阻止元素的默认事件    </span><br><span class="line">    this.style.backgroundColor = &#x27;#A5D9F3&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  var elements = document.getElementsByTagName(&#x27;*&#x27;);// 获取文档中的所有元素的列表</span><br><span class="line">  // 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line">  for(var i=0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">    elements[i].addEventListener(&#x27;click&#x27;, bluify, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>内联事件，内联事件中的this指向分两种情况：</li></ol><p>当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素<br>当代码被包括在函数内部执行时，其this指向等同于函数直接调用的情况，即在非严格模式指向全局对象window， 在严格模式指向undefined。<br>10. setTimeout &amp; setInterval，对于延时函数内部的回调函数的this指向全局对象window（当然我们可以通过bind方法改变其内部函数的this指向） </p><pre><code>//默认情况下function Person() &#123;      this.age = 0;      setTimeout(function() &#123;        console.log(this);    &#125;, 3000);&#125;//通过bind绑定function Person() &#123;      this.age = 0;      setTimeout((function() &#123;        console.log(this);    &#125;).bind(this), 3000);&#125;var p = new Person();//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</code></pre><ol start="11"><li><p>箭头函数中的 this，由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值 </p><p>&#x2F;&#x2F; call() &#x2F; apply() &#x2F; bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。<br>&#x2F;&#x2F;考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。（可以忽略是否在严格<br>&#x2F;&#x2F;模式下的影响）<br>&#x2F;&#x2F;因为箭头函数可以捕获其所在上下文的this值 所以:<br>function Person() {<br>this.age &#x3D; 0;<br>setInterval(() &#x3D;&gt; {<br>    this.age++;&#x2F;&#x2F; 回调里面的 <code>this</code> 变量就指向了期望的那个对象了<br>}, 3000);<br>}<br>var p &#x3D; new Person();<br>​&#x2F;&#x2F;以上代码可以得到我们所以希望的值，下图可以看到，在setTimeout中的this指向了构造函数新生成</p></li></ol><p>​    &#x2F;&#x2F;的对象，而普通函数指向了全局window对象</p><h3 id="二、Vue中的this"><a href="#二、Vue中的this" class="headerlink" title="二、Vue中的this"></a>二、Vue中的this</h3><ol><li>Vue methods</li></ol><p>来看看官方文档给出的解释：</p><p>methods 将被混入到 Vue 实例中。可以直接通过 实例vm 访问这些方法，或者在指令表达式中使用。方法中的 this自动绑定为 Vue 实例（vm）。</p><p>注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () &#x3D;&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。</p><p>长话短说，官方的意思是：在Vue实例中，methods中如果用的是正常函数，那么它的this就指向Vue实例；如果是箭头函数，this就指向window对象；</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>Vue methods 中不应该箭头函数定义methods函数，因为箭头函数绑定了父级作用域上下文，所以 this 打印出的结果是Window 对象；不使用箭头函数的情况下，this 实际上是指向了一个 Proxy 对象。</p><p>原因是vue 内部实际上对methods属性中的方法进行了遍历，将对应的方法通过bind绑定了this，使得this指向实例vm</p><ol start="2"><li>Vue中生命周期钩子和自定义方法中的this指向当前的 Vue 实例</li></ol><p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () &#x3D;&gt; this.checkTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.checkTodos 的行为未定义。</p><ol start="3"><li>Vue 中回调函数中的 this：</li></ol><p>若回调函数为匿名函数，非严格模式下指向 window,严格模式下为 undefined。<br>若回调函数为自定义方法，则 this 指向 Vue 实例。<br>若回调函数为 箭头函数，则 this 指向 Vue 实例。<br>4. Vue 中 addEventListener 中的 this</p><p>通常，事件监听函数中的 this 都指向绑定事件的那个元素, 但是在 Vue 中，监听函数中的 this 也指向 Vue 实例</p><ol start="5"><li>在data里定义Object类型的变量时的this</li></ol><p>在data里定义Object类型的变量时，会发现Object中访问不到vue的this属性，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      a: &quot;123&quot;,</span><br><span class="line">      b: &#123;</span><br><span class="line">        c: this.a</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&quot;b: &quot;, this.b.c); // undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想在b中访问this.a的数据，直接访问会返回undefined，因为这时c中的this指向的是b。这种情况可以用到Object的get属性进行属性定义，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      a: &quot;123&quot;,</span><br><span class="line">      b: &#123;</span><br><span class="line">        _target: () =&gt; this,</span><br><span class="line">        get target() &#123;</span><br><span class="line">          return this._target();</span><br><span class="line">        &#125;,</span><br><span class="line">        get c() &#123;</span><br><span class="line">          return this.target.a;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&quot;b: &quot;, this.b.c); // 123</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处将this映射到了Object变量内部，然后通过get的形式定义属性并获取，这样就解决问题啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零零碎碎</title>
      <link href="/2024/04/14/%E5%85%AB%E8%82%A1css/"/>
      <url>/2024/04/14/%E5%85%AB%E8%82%A1css/</url>
      
        <content type="html"><![CDATA[<h3 id="特性-继承、层叠、优先级"><a href="#特性-继承、层叠、优先级" class="headerlink" title="特性 继承、层叠、优先级"></a>特性 继承、层叠、优先级</h3><h3 id="CSS-单位中-px、em-和-rem-的区别？"><a href="#CSS-单位中-px、em-和-rem-的区别？" class="headerlink" title="CSS 单位中 px、em 和 rem 的区别？"></a>CSS 单位中 px、em 和 rem 的区别？</h3><p>一、px是<code>固定的像素</code>，一旦设置了就无法因为适应页面大小而改变。</p><p>二、em和rem相对于px更具有灵活性，他们是<code>相对长度</code>单位，意思是长度不是定死了的，更适用于响应式布局。</p><p>三、em是相对于其父元素来设置字体大小的，一般都是以的“font-size”为基准。这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值<br>font-size一般默认为16px.<br>总之：对于em和rem的区别一句话概括：</p><p>em相对于父元素，rem相对于根元素。</p><h3 id="水平垂直居中的几种方法"><a href="#水平垂直居中的几种方法" class="headerlink" title="水平垂直居中的几种方法"></a>水平垂直居中的几种方法</h3><ol><li><p>使用flex布局<br>利用flex的align-items:center垂直居中，justify-content:center水平居中</p></li><li><p>定位+margin:auto<br>父元素相对定位position：relative<br>子元素绝对定位position：absolute且 top、bottom、left、right均为0，再设置margin：0<br>就实现了子元素在父元素中居中</p></li><li><p>定位+transform<br>相对定位下，使用绝对定位，利用translate平移回补自身宽高的50%即可<br>position:absolute; transform:translate(-50%,-50%); tpo:50%; left:50%;</p></li><li><p>利用textAlign和verticalAlign<br>利用textAlign:center实现<code>行内元素</code>的水平居中，再利用verticalAlign:middle实现行内元素的垂直居中，前提是要先加上伪元素并给设置高度为100%，用过elementUI的可以去看看其消息弹窗居中实现方式就是如此</p></li><li><p>其他(grid布局+table布局)<br>上面都是在未知外容器和自身宽高下实现水平垂直居中的，如果已知其宽高，可以有更多种简单的方式实现居中，其原理无非是利用绝对定位的top&#x2F;left偏移、margin偏移、padding填充，在此就不分析了。还有就是单纯文字的居中利用lineHeight和textAlign即可实现。</p></li></ol><h3 id="如何隐藏一个元素"><a href="#如何隐藏一个元素" class="headerlink" title="如何隐藏一个元素"></a>如何隐藏一个元素</h3><p>display:none  display不能过渡 完全从页面上<code>移除元素</code>，用户不可交互。会触发reflow（重排）</p><p>visibility:hidden 可以与过渡动画结合 元素设置为不可见，<code>元素依然存在</code>，可以交互。布局不变。只会触发repaint（重绘）</p><p>opacity:0; （不透明度），元素不可见，<code>占据空间位置</code></p><p>position：absolute；</p><p>clip-path 裁剪</p><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><h3 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h3><ol><li>边框<br>留下想要指向方向相反的边框设定，其他方向的边框设为transparent透明<br>.div{<br>  height:0;<br>  widenth:0;<br>  border-top: 100px solid transparent;(实线边框，设为透明)<br>  border-left: 100px solid transparent;<br>  border-right: 100px solid transparent;<br>  border-bottom: 100px solid orangered;(绘出指向上的三角)<br>}</li><li>裁剪 clip-path<br>.div{<br> width: 100px;<br> height: 100px;<br> background: gold;<br> clip-path: polygon(0 0, 0 100%, 100% 100%); &#x2F;&#x2F;输入多边形，以左上角为0，0.<br> }</li><li>linear-gradient<br>一半有颜色，一半透明<br>.second{<br> background: linear-gradient(45deg, deeppink, deeppink 50%, transparent 50%, transparent 100%);<br> }</li></ol><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>HTML中所有元素都可以看成是一个盒子<br>标准盒模型：<br>内容（content）+ 内边距（padding）+ 边框（border）+ 外边距（margin）<br>IE盒模型<br>margin+content（border+padding）<br>控制盒模型的模式：box-sizing：content-box（默认值，标准盒模型），border-box（IE盒模型）</p><h3 id="什么是-reflow"><a href="#什么是-reflow" class="headerlink" title="什么是 reflow?"></a>什么是 reflow?</h3><p><strong>reflow 的本质就是重新计算 layout 树。</strong><br>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。<br>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。<br>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。I 浏览器在反复权衡下，最终决定获取属性立即 reflow.</p><p>回流（reflow）：<code>当render tree中的元素的宽高、布局、显示、隐藏或元素内部文字结结构发生改变时</code>，会影响自身及其父元素、甚至追溯到更多的祖先元素发生改变，则会导致元素内部、周围甚至整个页面的重新渲染，页面发生重构，回流就产生了。</p><h3 id="什么是-repaint"><a href="#什么是-repaint" class="headerlink" title="什么是 repaint?"></a>什么是 repaint?</h3><p><strong>repaint 的本质就是重新根据分层信息计算了绘制指令。</strong>当<code>改动了可见样式</code>后，就需要重新计算，会引发 repaint。<br>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><p>重绘（repaint）：元素的结构（宽高、布局、显示隐藏、内部文字大小）未发生改变，只是<code>元素的外观样式发生改变，比如背景颜色、内部文字颜色、边框颜色</code>等。此时会引起浏览器重绘，显然重绘的速度快于回流。</p><p>回流一定会触发重绘，重绘不一定触发回流。</p><h3 id="预处理器（scss-小程序开发语言-、less）"><a href="#预处理器（scss-小程序开发语言-、less）" class="headerlink" title="预处理器（scss(小程序开发语言)、less）"></a>预处理器（scss(小程序开发语言)、less）</h3><p>加入了函数、混入、变量等功能</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零零碎碎</title>
      <link href="/2024/04/03/%E5%85%AB%E8%82%A1html/"/>
      <url>/2024/04/03/%E5%85%AB%E8%82%A1html/</url>
      
        <content type="html"><![CDATA[<h3 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h3><ol><li>应用标签不同<br><strong>src</strong>属性的作用是<strong>指定要加载的资源路径</strong>，常出现于<code>&lt;script&gt;</code> 、<code>&lt;cimage&gt;</code> 、 <code>&lt;audio&gt;</code> 、<code>&lt;video&gt;</code>和<code>&lt;ciframe&gt;</code>等标签中，用于加载JavaScript脚本、图像、音频、视频或嵌入的网页文件。<br><strong>href</strong>属性的作用是<strong>指定超链接的目标地址</strong>或<strong>定义文档与外部资源的关联</strong>，主要用在<code>&lt;a&gt;</code> 、<code>&lt;clink&gt;</code> 、 <code>&lt;area&gt;</code>等标签中。例如，当你创建一个超链接<code>&lt;a&gt;</code>时，需要用href属性指定用户点击后跳转的目标URL;或者当你在文档头部使用<code>&lt;link&gt;</code>标签引入外部样式表时，也是使用href属性来指定样式表的地址。</li><li>资源加载方式不同<br>当浏览器解析到适用于<strong>src属性</strong>的标签（比如<code>&lt;script&gt;</code>和<code>&lt;img&gt;</code>）时，会<strong>暂停其他资源的下载和处理</strong>，直到将该资源<strong>加载</strong>、<strong>编译</strong>(如果是JavaScript)、<strong>执行</strong>（如果是脚本）完成。这种方式称为<strong>阻塞加载</strong>，所以<code>一般建议将JavaScript脚本放在页面底部</code>。而当浏览器识别到适用于<strong>href</strong>属性的标签(比如<code>&lt;a&gt;</code>和<code>&lt;clink&gt;</code>)时，会<code>并行下载资源</code>，不会停止对当前文档的处理。这种方式称为<code>非阻塞加载</code>，浏览器可以同时处理超链接或引入样式表。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情景题</title>
      <link href="/2024/03/26/%E6%83%85%E6%99%AF%E9%A2%98/"/>
      <url>/2024/03/26/%E6%83%85%E6%99%AF%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器从URL输出到页面加载的全过程"><a href="#浏览器从URL输出到页面加载的全过程" class="headerlink" title="浏览器从URL输出到页面加载的全过程"></a>浏览器从URL输出到页面加载的全过程</h3><p>————————————————<br>浏览器地址栏输入url地址，首先要在客户端上进行url解析<br>浏览器会首先查看自身的缓存，如果浏览器缓存中有对应的解析记录，直接返回结果<br>如果浏览器没有缓存，电脑会查看本地操作系统的缓存，如果有记录，直接返回结果（host文件）<br>如果本地没有缓存该域名的IP地址，就需要通过递归或迭代的方式向根域名服务器、顶级域名服务器、权威域名服务器发起查询请求，直至返回一个IP地址给浏览器。<br>然后根据该IP地址建立TCP连接。<br>客户端发送HTTP请求，服务器返回报文，关闭TCP连接。<br>浏览器内核拿到相应内容后，<br>解析html,css分别建立DOM Tree和CSSOM Tree<br>随后这两个合并成Render Tree。<br>然后布局Render Tree，绘制Render Tree，绘制页面像素信息。<br>浏览器会将各层的信息发送给GPU,GPU会将各层合成，显示在屏幕上。<br>渲染完成。<br>————————————————<br>详细简版：<br>1 从浏览器接收 url 到开启⽹络请求线程（这⼀部分可以展开浏览器的机制以及进程与线程 之间的关系）</p><p>2 开启⽹络线程到发出⼀个完整的 HTTP 请求（这⼀部分涉及到dns查询， TCP&#x2F;IP 请求，五层因特⽹协议栈等知识）</p><p>3 从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</p><p>4 后台和前台的 HTTP 交互（这⼀部分包括 HTTP 头部、响应码、报⽂结构、 cookie 等知 识，可以提下静态资源 的 cookie 优化，以及编码解码，如 gzip 压缩等）</p><p>6 单独拎出来的缓存问题， HTTP 的缓存（这部分包括http缓存头部， ETag ， catchcontrol 等）<br>浏览器接收到 HTTP 数据包后的解析流程（解析 html、 词法分析然后解析成 dom 树、解析 css ⽣成 css 规则树、合并成 render 树，然后 layout 、 painting 渲染、复合图层的合成、 GPU 绘制、外链资源的处理、 loaded 和 DOMContentLoaded 等）</p><p>7 CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框， BFC ， IFC 等概念）<br>JS 引擎解析过程（ JS 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， VO ，作 ⽤域链、回收机制等等）</p><p>8 其它（可以拓展不同的知识模块，如跨域，web安全， hybrid 模式等等内容）</p><h3 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h3><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。<br>整个渲染流程分为多个阶段，分别是：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><h4 id="渲染的第一步是解析-HTML。"><a href="#渲染的第一步是解析-HTML。" class="headerlink" title="渲染的第一步是解析 HTML。"></a>渲染的第一步是解析 HTML。</h4><p>解析过程中遇到 CSS 解析 CSS, 遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。<br>如果主线程解析到 Link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。<br>如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。<br>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><h4 id="渲染的下一步是样式计算。"><a href="#渲染的下一步是样式计算。" class="headerlink" title="渲染的下一步是样式计算。"></a>渲染的下一步是样式计算。</h4><p>主线程会遍历得到的DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style.在这一过程中，很多预设值会变成绝对值，比如 red 会变成 rgb(255, 0, 0)；相对单位会变成绝对单位，比如 em 会变成 px<br>这一步完成后，会得到一棵带有样式的 DOM 树。</p><h4 id="接下来是布局，布局完成后会得到布局树。"><a href="#接下来是布局，布局完成后会得到布局树。" class="headerlink" title="接下来是布局，布局完成后会得到布局树。"></a>接下来是布局，布局完成后会得到布局树。</h4><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。<br>大部分时候，DOM 树和布局树并非一一对应。<br>比如 display:none 的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法——对应。</p><h4 id="下一步是分层"><a href="#下一步是分层" class="headerlink" title="下一步是分层"></a>下一步是分层</h4><p>主线程会使用一套复杂的策略对整个布局树中进行分层。<br>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。<br>滚动条、堆叠上下文、transform. opacity 等样式都会或多或少的影的分层结果，也可以通过will-change 属性更大程度的影响分层结果。</p><h4 id="再下一步是绘制"><a href="#再下一步是绘制" class="headerlink" title="再下一步是绘制"></a>再下一步是绘制</h4><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。<br>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。<br>它会从线程池中拿取多个线程来完成分块工作。</p><h4 id="分块完成后，进入光栅化阶段。"><a href="#分块完成后，进入光栅化阶段。" class="headerlink" title="分块完成后，进入光栅化阶段。"></a>分块完成后，进入光栅化阶段。</h4><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。<br>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块<br>光栅化的结果，就是一块一块的位图</p><h4 id="最后一个阶段就是画了"><a href="#最后一个阶段就是画了" class="headerlink" title="最后一个阶段就是画了"></a>最后一个阶段就是画了</h4><p>教言<br>合成线程拿到每个层、每个块的位图后，生成一个个「指引(quad)」信息。<br>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。<br>变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。<br>ation<br>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><ol start="4"><li>为什么 transform 的效率高?<br>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个 「draw」 阶段由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</li></ol><h3 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h3><p>先执行同步任务后执行异步任务，执行异步任务的时候先执行微任务（.then,await）后执行宏任务（setinterval,setTimeout,nextTick）。</p><h3 id="首页白屏问题"><a href="#首页白屏问题" class="headerlink" title="首页白屏问题"></a>首页白屏问题</h3><ol><li>确保<code>静态资源的路径配置</code>正确，检查Vue项目的config文件或者Webpack 的配置文件。</li><li>确认所有<code>依赖包已经正确安装，版本兼容</code>。如果有多个版本的Vue依赖包，可能会导致冲突</li><li>确保<code>网络请求</code>的API正常工作，可以通过console日志或vue devtools验证。</li><li>检查<code>Vue Router的配置</code>，包括路径匹配和重定向设置。</li><li>审查<code>Webpack配置</code>，特别是output和publicPath设置。</li><li>如果使用SSR（(<code>服务端</code>渲染)，检查后端服务是否正常运行。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇总</title>
      <link href="/2024/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2024/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="一、CSS"><a href="#一、CSS" class="headerlink" title="一、CSS"></a>一、CSS</h3><h5 id="1-说一下CSS的盒模型。"><a href="#1-说一下CSS的盒模型。" class="headerlink" title="1.说一下CSS的盒模型。"></a>1.说一下CSS的盒模型。</h5><p>​        在HTML页面中的所有元素都可以看成是一个盒子<br>​        盒子的组成：内容content、内边距padding、边框border、外边距margin<br>​        盒模型的类型：<br>​            标准盒模型（W3C）<br>​                margin + border + padding + content<br>​            IE盒模型（怪异）<br>​                margin + content(border + padding)<br>​        控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）;</p><h5 id="2-CSS选择器的优先级？"><a href="#2-CSS选择器的优先级？" class="headerlink" title="2.CSS选择器的优先级？"></a>2.CSS选择器的优先级？</h5><p>​        CSS的特性：继承性、层叠性、优先级<br>​        优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式<br>​        标签、类&#x2F;伪类&#x2F;属性、全局选择器、行内样式、id、!important<br>​        !important &gt; 行内样式 &gt; id &gt; 类&#x2F;伪类&#x2F;属性 &gt; 标签 &gt; 全局选择器</p><h5 id="3-隐藏元素的方法有哪些？"><a href="#3-隐藏元素的方法有哪些？" class="headerlink" title="3.隐藏元素的方法有哪些？"></a>3.隐藏元素的方法有哪些？</h5><p>​        display:none;<br>​            元素在页面上消失，不占据空间<br>​        opacity:0;<br>​            设置了元素的透明度为0，元素不可见，占据空间位置<br>​        visibility:hidden;<br>​            让元素消失，占据空间位置，一种不可见的状态<br>​        position:absolute;<br>​        clip-path</p><h5 id="4-px和rem的区别是什么？"><a href="#4-px和rem的区别是什么？" class="headerlink" title="4.px和rem的区别是什么？"></a>4.px和rem的区别是什么？</h5><p>​        px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度<br>​        rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;<br>​            1rem &#x3D; 10px; （16px*62.5%&#x3D;10px）</p><h5 id="5-重绘重排有什么区别？"><a href="#5-重绘重排有什么区别？" class="headerlink" title="5.重绘重排有什么区别？"></a>5.重绘重排有什么区别？</h5><p>​        重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小<br>​        重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制<br>​        浏览器的渲染机制<br>​        对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排<br>​        对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘</p><h5 id="6-让一个元素水平垂直居中的方式有哪些？"><a href="#6-让一个元素水平垂直居中的方式有哪些？" class="headerlink" title="6.让一个元素水平垂直居中的方式有哪些？"></a>6.让一个元素水平垂直居中的方式有哪些？</h5><p>​        1.定位+margin 子绝父相 top、bottom、left、right、margin&#x3D;0;<br>​        2.定位+transform 子绝父相 子 transform：translate(-50%,-50%);top:50%,left:50%;<br>​        3.flex布局 align-items:center; justify-content:center<br>​        4.grid布局<br>​        5.table布局</p><h5 id="7-CSS的哪些属性哪些可以继承？哪些不可以继承？"><a href="#7-CSS的哪些属性哪些可以继承？哪些不可以继承？" class="headerlink" title="7.CSS的哪些属性哪些可以继承？哪些不可以继承？"></a>7.CSS的哪些属性哪些可以继承？哪些不可以继承？</h5><p>​        CSS的三大特性：继承、层叠、优先级<br>​        子元素可以继承父类元素的样式<br>​        1.字体的一些属性：font<br>​        2.文本的一些属性：line-height<br>​        3.元素的可见性：visibility:hidden<br>​        4.表格布局的属性：border-spacing<br>​        5.列表的属性：list-style<br>​        6.页面样式属性：page<br>​        7.声音的样式属性</p><h5 id="8-有没有用过预处理器？"><a href="#8-有没有用过预处理器？" class="headerlink" title="8.有没有用过预处理器？"></a>8.有没有用过预处理器？</h5><p>​        预处理语言增加了变量、函数、混入等强大的功能<br>​        SASS  LESS<br>​        </p><h3 id="二、JavaSscipt"><a href="#二、JavaSscipt" class="headerlink" title="二、JavaSscipt"></a>二、JavaSscipt</h3><h5 id="1-JS由哪三部分组成？"><a href="#1-JS由哪三部分组成？" class="headerlink" title="1.JS由哪三部分组成？"></a>1.JS由哪三部分组成？</h5><pre><code>    ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串），    文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档    浏览器对象模型（BOM）：对浏览器窗口进行访问和操作</code></pre><h5 id="2-JS有哪些内置对象？"><a href="#2-JS有哪些内置对象？" class="headerlink" title="2.JS有哪些内置对象？"></a>2.JS有哪些内置对象？</h5><pre><code>    String Boolean Number Array Object Function Math Date RegExp...    Math        abs() sqrt() max() min()    Data        new Data() getYear()     Array    String        concat() length  slice() split()</code></pre><h5 id="3-操作数组的方法有哪些？"><a href="#3-操作数组的方法有哪些？" class="headerlink" title="3.操作数组的方法有哪些？"></a>3.操作数组的方法有哪些？</h5><pre><code>    push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter()    ervery() some() reduce() isArray() findIndex()    哪些方法会改变原数组？        push() pop() unshift() shift() sort() reverse() splice()</code></pre><h5 id="4-JS对数据类的检测方式有哪些？"><a href="#4-JS对数据类的检测方式有哪些？" class="headerlink" title="4.JS对数据类的检测方式有哪些？"></a>4.JS对数据类的检测方式有哪些？</h5><pre><code>    typeof()    instanceof()    constructor    Object.prototype.toString.call()</code></pre><h5 id="5-说一下闭包，闭包有什么特点？"><a href="#5-说一下闭包，闭包有什么特点？" class="headerlink" title="5.说一下闭包，闭包有什么特点？"></a>5.说一下闭包，闭包有什么特点？</h5><pre><code>    什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包    特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存再内存中，不会被垃圾回收机制回收    缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏    使用场景：防抖，节流，函数嵌套函数避免全局污染的时候</code></pre><h5 id="6-前端的内存泄漏怎么理解？"><a href="#6-前端的内存泄漏怎么理解？" class="headerlink" title="6.前端的内存泄漏怎么理解？"></a>6.前端的内存泄漏怎么理解？</h5><pre><code>    JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。    垃圾回收机制    因素：一些为生命直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。</code></pre><h5 id="7-事件委托是什么？"><a href="#7-事件委托是什么？" class="headerlink" title="7.事件委托是什么？"></a>7.事件委托是什么？</h5><pre><code>    又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上    如果子元素组织了事件冒泡，那么委托也就不成立    组织事件冒泡：event.stopPropagation()    addEventListener(&#39;click&#39;,函数名，true/false) 默认是false（事件冒泡），true（事件捕获）    好处：提高性能，减少事件的绑定，也就减少了内存的占用。</code></pre><h5 id="8-基本数据类型和引用数据类型的区别？"><a href="#8-基本数据类型和引用数据类型的区别？" class="headerlink" title="8.基本数据类型和引用数据类型的区别？"></a>8.基本数据类型和引用数据类型的区别？</h5><pre><code>    基本数据类型：String Number Boolean undefined null        基本数据类型保存在栈内存当中，保存的就是一个具体的值    引用数据类型（复杂数据类型）：Object Function Array        保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址        假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变</code></pre><h5 id="9-说一下原型链。"><a href="#9-说一下原型链。" class="headerlink" title="9.说一下原型链。"></a>9.说一下原型链。</h5><pre><code>    原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象    使用prototype可以把方法挂在原型上，内存值保存一份    __proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）</code></pre><h5 id="10-new操作符具体做了什么？"><a href="#10-new操作符具体做了什么？" class="headerlink" title="10.new操作符具体做了什么？"></a>10.new操作符具体做了什么？</h5><pre><code>    1.先创建一个空对象    let obj=Object.creat();    2.把空对象和构造函数通过原型链进行链接    obj._proto_=Person.prototype;    3.把构造函数的this绑定到新的空对象身上    let result=Person.call(obj);    4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型    if(typeof(result)==&quot;object&quot;)&#123;      person=result;    &#125;else&#123;      person=obj;    &#125;</code></pre><h5 id="11-JS是如何实现继承的？"><a href="#11-JS是如何实现继承的？" class="headerlink" title="11.JS是如何实现继承的？"></a>11.JS是如何实现继承的？</h5><pre><code>    1.原型链继承    2.借用构造函数继承    3.组合式继承    4.ES6的class类继承</code></pre><h5 id="12-JS的设计原理是什么？"><a href="#12-JS的设计原理是什么？" class="headerlink" title="12.JS的设计原理是什么？"></a>12.JS的设计原理是什么？</h5><pre><code>    JS引擎 运行上下文 调用栈 事件循环 回调</code></pre><h5 id="13-JS中关于this指向的问题"><a href="#13-JS中关于this指向的问题" class="headerlink" title="13.JS中关于this指向的问题"></a>13.JS中关于this指向的问题</h5><pre><code>    1. 全局对象中的this指向        指向的是window    2. 全局作用域或者普通函数中的this        指向全局window    3. this永远指向最后调用它的那个对象        在不是箭头函数的情况下    4. new 关键词改变了this的指向    5. apply,call,bind        可以改变this指向，不是箭头函数    6. 箭头函数中的this        它的指向在定义的时候就已经确定了        箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window    7. 匿名函数中的this        永远指向了window,匿名函数的执行环境具有全局性，因此this指向window</code></pre><h5 id="14-script标签里的async和defer有什么区别？"><a href="#14-script标签里的async和defer有什么区别？" class="headerlink" title="14.script标签里的async和defer有什么区别？"></a>14.script标签里的async和defer有什么区别？</h5><pre><code>    当没有async和defer这两个属性的时候，        浏览器会立刻加载并执行指定的脚本    有async        加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）    有defer        加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要等        所有元素解析完成之后才会执行</code></pre><h5 id="15-setTimeout最小执行时间是多少？"><a href="#15-setTimeout最小执行时间是多少？" class="headerlink" title="15.setTimeout最小执行时间是多少？"></a>15.setTimeout最小执行时间是多少？</h5><pre><code>    HTML5规定的内容：        setTimeout最小执行时间是4ms        setInterval最小执行时间是10ms</code></pre><h5 id="16-ES6和ES5有什么区别？"><a href="#16-ES6和ES5有什么区别？" class="headerlink" title="16.ES6和ES5有什么区别？"></a>16.ES6和ES5有什么区别？</h5><pre><code>    JS的组成：ECMAScript BOM  DOM    ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009    ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准</code></pre><h5 id="17-ES6的新特性有哪些？"><a href="#17-ES6的新特性有哪些？" class="headerlink" title="17.ES6的新特性有哪些？"></a>17.ES6的新特性有哪些？</h5><pre><code>    1.新增块级作用域（let,const）        不存在变量提升        存在暂时性死区的问题        块级作用域的内容        不能在同一个作用域内重复声明    2.新增了定义类的语法糖（class）    3.新增了一种基本数据类型（symbol）    4.新增了解构赋值        从数组或者对象中取值，然后给变量赋值    5.新增了函数参数的默认值    6.给数组新增了API    7.对象和数组新增了扩展运算符    8.Promise        解决回调地狱的问题。        自身有all,reject,resolve,race方法        原型上有then,catch        把异步操作队列化        三种状态：pending初始状态,fulfilled操作成功,rejected操作失败        状态：pending -&gt; fulfilled;pending -&gt; rejected 一旦发生，状态就会凝固，不会再变        async  await            同步代码做异步的操作，两者必须搭配使用            async表明函数内有异步操作，调用函数会返回promise            await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用            await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行    9.新增了模块化（import,export）    10.新增了set和map数据结构        set就是不重复        map的key的类型不受限制    11.新增了generator    12.新增了箭头函数        不能作为构造函数使用，不能用new        箭头函数就没有原型        箭头函数没有arguments        箭头函数不能用call,apply,bind去改变this的执行        this指向外层第一个函数的this</code></pre><h5 id="18-call-apply-bind三者有什么区别？"><a href="#18-call-apply-bind三者有什么区别？" class="headerlink" title="18.call,apply,bind三者有什么区别？"></a>18.call,apply,bind三者有什么区别？</h5><pre><code>    都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同    call方法传的是一个参数列表    apply传递的是一个数组    bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()    call方法的性能要比apply好一些，所以call用的更多一点</code></pre><h5 id="19-用递归的时候有没有遇到什么问题？"><a href="#19-用递归的时候有没有遇到什么问题？" class="headerlink" title="19.用递归的时候有没有遇到什么问题？"></a>19.用递归的时候有没有遇到什么问题？</h5><pre><code>    如果一个函数内可以调用函数本身，那么这个就是递归函数    函数内部调用自己    特别注意：写递归必须要有退出条件return</code></pre><h5 id="20-如何实现一个深拷贝？"><a href="#20-如何实现一个深拷贝？" class="headerlink" title="20.如何实现一个深拷贝？"></a>20.如何实现一个深拷贝？</h5><pre><code>    深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响    主要针对的是引用数据类型    1.扩展运算符    2.JSON.parse(JSON.stringify())    3.利用递归函数实现</code></pre><h5 id="21-说一下事件循环。"><a href="#21-说一下事件循环。" class="headerlink" title="21.说一下事件循环。"></a>21.说一下事件循环。</h5><pre><code>    JS是一个单线程的脚本语言    主线程 执行栈 任务队列  宏任务 微任务    主线程先执行同步任务(script)，然后才去执行任务队列里的任务，如果在执行宏任务（setTimeout）之前有微任务（promise、nextTick），那么要先执行微任务    全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！    promise本身是同步的，但是catch、then回调函数是异步的（微任务）注意不能被resolve(成功)和reject（失败）迷惑，要看.then的位置，还有promise状态只能改变一次    promise 与then 相当于async 与await（后者基于promise）</code></pre><h5 id="22-ajax是什么？怎么实现的？"><a href="#22-ajax是什么？怎么实现的？" class="headerlink" title="22.ajax是什么？怎么实现的？"></a>22.ajax是什么？怎么实现的？</h5><pre><code>    创建交互式网页应用的网页开发技术        在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容    通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面    1.创建XmlHttpRequest对象 xmh    2.通过xmh对象里的open()方法和服务器建立连接    3.构建请求所需的数据，并通过xmh对象的send()发送给服务器    4.通过xmh对象的onreadystate chansge事件监听服务器和你的通信状态    5.接收并处理服务器响应的数据结果    6.把处理的数据更新到HTML页面上</code></pre><h5 id="23-get和post有什么区别？"><a href="#23-get和post有什么区别？" class="headerlink" title="23.get和post有什么区别？"></a>23.get和post有什么区别？</h5><pre><code>    1.get一般是获取数据，post一般是提交数据    2.get参数会放在url上，所以安全性比较差，post是放在body中    3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据    4.get请求时会被缓存,post请求不会被缓存    5.get请求会被保存在浏览器历史记录中,post不会    6.get请求只能进行url编码，post请求支持很多种</code></pre><h5 id="24-promise的内部原理是什么？它的优缺点是什么？"><a href="#24-promise的内部原理是什么？它的优缺点是什么？" class="headerlink" title="24.promise的内部原理是什么？它的优缺点是什么？"></a>24.promise的内部原理是什么？它的优缺点是什么？</h5><pre><code>    Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果    Promise主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，    就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差    有三种状态：pending初始状态  fulfilled成功状态  rejected失败状态    状态改变只会有两种情况，        pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变    首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消    如果不设置回调，promise内部抛出的错误就无法反馈到外面    若当前处于pending状态时，无法得知目前在哪个阶段。    原理：        构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一个是reject        promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数</code></pre><h5 id="25-promise和async-await的区别是什么？"><a href="#25-promise和async-await的区别是什么？" class="headerlink" title="25.promise和async await的区别是什么？"></a>25.promise和async await的区别是什么？</h5><pre><code>    1.都是处理异步请求的方式    2.promise是ES6，async await 是ES7的语法    3.async await是基于promise实现的，他和promise都是非阻塞性的    优缺点：    1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常    2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作    promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作</code></pre><h5 id="26-浏览器的存储方式有哪些？"><a href="#26-浏览器的存储方式有哪些？" class="headerlink" title="26.浏览器的存储方式有哪些？"></a>26.浏览器的存储方式有哪些？</h5><pre><code>    1.cookies        H5标准前的本地存储方式        兼容性好，请求头自带cookie        存储量小，资源浪费，使用麻烦（封装）    2.localstorage        H5加入的以键值对为标准的方式        操作方便，永久存储，兼容性较好        保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫    3.sessionstorage        当前页面关闭后就会立刻清理，会话级别的存储方式    4.indexedDB        H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景</code></pre><h5 id="27-token存在sessionstorage还是loaclstorage？"><a href="#27-token存在sessionstorage还是loaclstorage？" class="headerlink" title="27.token存在sessionstorage还是loaclstorage？"></a>27.token存在sessionstorage还是loaclstorage？</h5><pre><code>    token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串    1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台    2.存cookie中，会自动发送，缺点就是不能跨域    如果存在localstorage中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊    如果存在cookie中会有CSRF攻击</code></pre><h5 id="28-token的登录流程。"><a href="#28-token的登录流程。" class="headerlink" title="28.token的登录流程。"></a>28.token的登录流程。</h5><pre><code>    1.客户端用账号密码请求登录    2.服务端收到请求后，需要去验证账号密码    3.验证成功之后，服务端会签发一个token，把这个token发送给客户端    4.客户端收到token后保存起来，可以放在cookie也可以是localstorage    5.客户端每次向服务端发送请求资源的时候，都需要携带这个token    6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据</code></pre><h5 id="29-页面渲染的过程是怎样的？"><a href="#29-页面渲染的过程是怎样的？" class="headerlink" title="29.页面渲染的过程是怎样的？"></a>29.页面渲染的过程是怎样的？</h5><pre><code>    DNS解析    建立TCP连接    发送HTTP请求    服务器处理请求    渲染页面        浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树        再把CSS解析成CSSOM        把DOM和CSSOM合并为渲染树        布局        把渲染树的每个节点渲染到屏幕上（绘制）    断开TCP连接</code></pre><h5 id="30-DOM树和渲染树有什么区别？"><a href="#30-DOM树和渲染树有什么区别？" class="headerlink" title="30.DOM树和渲染树有什么区别？"></a>30.DOM树和渲染树有什么区别？</h5><pre><code>    DOM树是和HTML标签一一对应的，包括head和隐藏元素    渲染树是不包含head和隐藏元素</code></pre><h5 id="31-精灵图和base64的区别是什么？"><a href="#31-精灵图和base64的区别是什么？" class="headerlink" title="31.精灵图和base64的区别是什么？"></a>31.精灵图和base64的区别是什么？</h5><pre><code>    精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度    base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串    base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。</code></pre><h5 id="32-svg格式了解多少？"><a href="#32-svg格式了解多少？" class="headerlink" title="32.svg格式了解多少？"></a>32.svg格式了解多少？</h5><pre><code>    基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真    1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作        &lt;svg&gt;&lt;/svg&gt;    2.SVG可作为文件被引入        &lt;img src=&quot;pic.svg&quot; /&gt;    3.SVG可以转为base64引入页面</code></pre><h5 id="33-了解过JWT吗？"><a href="#33-了解过JWT吗？" class="headerlink" title="33.了解过JWT吗？"></a>33.了解过JWT吗？</h5><pre><code>    JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输    信息传输、授权    JWT的认证流程    1.前端把账号密码发送给后端的接口    2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。    3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内    4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）    5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果    简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。</code></pre><h5 id="34-npm的底层环境是什么？"><a href="#34-npm的底层环境是什么？" class="headerlink" title="34.npm的底层环境是什么？"></a>34.npm的底层环境是什么？</h5><pre><code>    node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境    npm的组成：网站、注册表、命令行工具</code></pre><h5 id="35-HTTP协议规定的协议头和请求头有什么？"><a href="#35-HTTP协议规定的协议头和请求头有什么？" class="headerlink" title="35.HTTP协议规定的协议头和请求头有什么？"></a>35.HTTP协议规定的协议头和请求头有什么？</h5><pre><code>    1.请求头信息：        Accept:浏览器告诉服务器所支持的数据类型        Host:浏览器告诉服务器我想访问服务器的哪台主机        Referer:浏览器告诉服务器我是从哪里来的（防盗链）        User-Agent:浏览器类型、版本信息        Date:浏览器告诉服务器我是什么时候访问的        Connection:连接方式        Cookie        X-Request-With:请求方式    2.响应头信息：        Location:这个就是告诉浏览器你要去找谁        Server:告诉浏览器服务器的类型        Content-Type:告诉浏览器返回的数据类型        Refresh:控制了的定时刷新</code></pre><h5 id="36-说一下浏览器的缓存策略。"><a href="#36-说一下浏览器的缓存策略。" class="headerlink" title="36.说一下浏览器的缓存策略。"></a>36.说一下浏览器的缓存策略。</h5><pre><code>    强缓存（本地缓存）、协商缓存（弱缓存）    强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能    协缓：需要像后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容    强缓存的触发：        HTTP1.0:时间戳响应标头        HTTP1.1:Cache-Control响应标头    协商缓存触发：        HTTP1.0:请求头：if-modified-since 响应头：last-modified        HTTP1.1:请求头：if-none-match 响应头：Etag</code></pre><h5 id="37-说一下什么是“同源策略”？"><a href="#37-说一下什么是“同源策略”？" class="headerlink" title="37.说一下什么是“同源策略”？"></a>37.说一下什么是“同源策略”？</h5><pre><code>    http:// www.  aaa.com:8080/index/vue.js    协议    子域名 主域名  端口号     资源    同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击    主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域    三个允许跨域加载资源的标签：img  link  script    跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了（结果卡在浏览器校验）！      跨域限制DOM，cookie，Ajax访问。服务器（后）端能改变就设置cors、jsonp，不能改就设置代理服务器。    服务器之间没有跨域限制。    JSONP（很老） 利用&lt;script&gt;标签可以跨域的特性发送请求，只能解决get请求。    jQuary封装的jsonp供前端调用。    CORS （跨域资源共享） 分为简单请求（get、head、post、更改请求头的请求）和复杂请求    服务器端可用cors库（直接封装好的响应头）    简单请求在服务端加上 Access-Control-Allow-Origin 等响应头，来声明允许哪些域进行资源共享。    复杂请求中会发送预检请求，要在服务器端加上响应头    /*</code></pre><p>  ● Access-Control-Allow-Origin：指定哪些源可以访问资源。可以是具体的一个URL（如<a href="http://example.com),或者*表示允许任何源./">http://example.com），或者*表示允许任何源。</a><br>  ● Access-Control-Allow-Methods：指定允许的HTTP方法，如GET, POST, DELETE等。<br>  ● Access-Control-Allow-Headers：指定允许的请求头列表，浏览器会在预检请求中使用此头部告知服务器实际请求中会使用哪些头部。<br>  ● Access-Control-Allow-Credentials：指示是否允许发送Cookie。如果这个值是true，Access-Control-Allow-Origin就不能设置为<em>，必须指定明确的、与请求网页一致的域名。<br>  ● Access-Control-Max-Age：指定预检请求的结果能够被缓存多长时间。<br>  ● Access-Control-Expose-Headers：指定允许浏览器访问的服务器响应头。默认情况下，只有6个基本响应头是可以读的：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。<br><em>&#x2F;<br>response.header(‘Access-Control-Allow-Origin’,’</em>‘)<br>response.header(‘Access-Control-Allow-Methods’,’</em>‘)<br>response.header(‘Access-Control-Allow-Headers’,’*’)<br>        websocket</p><pre><code>    反向代理（nginx）/自己设置代理服务器</code></pre><h5 id="38-防抖和节流是什么？"><a href="#38-防抖和节流是什么？" class="headerlink" title="38.防抖和节流是什么？"></a>38.防抖和节流是什么？</h5><pre><code>    都是应对页面中频繁触发事件的优化方案    防抖:避免事件重复触发 (只执行最后一次)     使用场景:1.频繁和服务端交互 2.输入框的自动保存事件    代码实现思路：定时器    let timer=null//定时器    document.quarySelector(&#39;ipt&#39;).onkeyup=function()&#123;    //防抖 键盘弹起事件 触发一次就把上一次的定时器清除再执行新的定时器    if(timer!==null)    clearTimeout(timer)；    &#125;    timer=setTimeout(()=&gt;&#123;    console.log(&quot;防抖&quot;)    &#125;,1000)    &#125;      节流:把频繁触发的事件减少,每隔一段时间执行 （只执行一次）    使用场景:scroll事件 轮播图 鼠标滑动 快速点击        代码实现思路：定时器    let timer=null//定时器    document.quarySelector(&#39;ipt&#39;).onmouseover=function()&#123;    //节流 鼠标经过事件 等定时器执行完毕，再执行新的定时器    if(timer!==null)    return     &#125;    timer=setTimeout(()=&gt;&#123;    console.log(&quot;节流&quot;);    timer=null;    &#125;,100)    &#125;</code></pre><h5 id="39-解释一下什么是json？"><a href="#39-解释一下什么是json？" class="headerlink" title="39.解释一下什么是json？"></a>39.解释一下什么是json？</h5><pre><code>    JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输    JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中    JS提供了JSON.parse() JSON.stringify()    什么时候使用json：定义接口；序列化；生成token；配置文件package.json</code></pre><h5 id="40-当数据没有请求过来的时候，该怎么做？"><a href="#40-当数据没有请求过来的时候，该怎么做？" class="headerlink" title="40.当数据没有请求过来的时候，该怎么做？"></a>40.当数据没有请求过来的时候，该怎么做？</h5><pre><code>    可以在渲染数据的地方给一些默认的值    if判断语句</code></pre><h5 id="41-有没有做过无感登录？"><a href="#41-有没有做过无感登录？" class="headerlink" title="41.有没有做过无感登录？"></a>41.有没有做过无感登录？</h5><pre><code>    1.在相应其中拦截，判断token返回过期后，调用刷新token的接口    2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口    3.写定时器，定时刷新token接口    流程：        1.登录成功后保存token 和 refresh_token        2.在响应拦截器中对401状态码引入刷新token的api方法调用        3.替换保存本地新的token        4.把错误对象里的token替换        5.再次发送未完成的请求        6.如果refresh_token过期了，判断是否过期，过期了就清楚所有token重新登录</code></pre><h5 id="42-大文件上传是怎么做的？"><a href="#42-大文件上传是怎么做的？" class="headerlink" title="42.大文件上传是怎么做的？"></a>42.大文件上传是怎么做的？</h5><pre><code>    分片上传：        1.把需要上传的文件按照一定的规则，分割成相同大小的数据块        2.初始化一个分片上传任务，返回本次分片上传的唯一标识        3.按照一定的规则把各个数据块上传        4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件    断点续传：        服务端返回，从哪里开始  浏览器自己处理</code></pre><h3 id="三、HTML5-、CSS3"><a href="#三、HTML5-、CSS3" class="headerlink" title="三、HTML5 、CSS3"></a>三、HTML5 、CSS3</h3><h5 id="1-语义化的理解。"><a href="#1-语义化的理解。" class="headerlink" title="1.语义化的理解。"></a>1.语义化的理解。</h5><pre><code>    在写HTML页面结构时所用的标签有意义    头部用head  主体用main  底部用foot...    怎么判断页面是否语义化了？        把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常    为什么要选择语义化？        1.让HTML结构更加清晰明了        2.方便团队协作，利于开发        3.有利于爬虫和SEO        4.能够让浏览器更好的去解析代码        5.给用户带来良好的体验</code></pre><h5 id="2-H5C3有哪些新特性？"><a href="#2-H5C3有哪些新特性？" class="headerlink" title="2.H5C3有哪些新特性？"></a>2.H5C3有哪些新特性？</h5><pre><code>    H5的新特性：        1.语义化的标签        2.新增音频视频        3.画布canvas        4.数据存储localstorage sessionstorage        5.增加了表单控件 email url search...        6.拖拽释放API    CSS3的新特性：        1.新增选择器：属性选择器、伪类选择器、伪元素选择器        2.增加了媒体查询        3.文字阴影        4.边框        5.盒子模型box-sizing        6.渐变        7.过度        8.自定义动画        9.背景的属性        10.2D和3D</code></pre><h5 id="3-rem是如何做适配的？"><a href="#3-rem是如何做适配的？" class="headerlink" title="3.rem是如何做适配的？"></a>3.rem是如何做适配的？</h5><pre><code>    rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配    rem是根据根元素font-size计算值的倍数    比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem = 16px*1.2 = 19.2px.</code></pre><h5 id="4-解决了哪些移动端的兼容问题？"><a href="#4-解决了哪些移动端的兼容问题？" class="headerlink" title="4.解决了哪些移动端的兼容问题？"></a>4.解决了哪些移动端的兼容问题？</h5><pre><code>    1.当设置样式overflow:scroll/auto时，IOS上的华东会卡顿        -webkit-overflow-scrolling:touch;    2.在安卓环境下placeholder文字设置行高时会偏上        input有placeholder属性的时候不要设置行高    3.移动端字体小于12px时异常显示        应该先把在整体放大一倍，然后再用transform进行缩小    4.ios下input按钮设置了disabled属性为true显示异常        input[typy=button]&#123;            opcity:1        &#125;    5.安卓手机下取消语音输入按钮        input::-webkit-input-speech-button&#123;            display:none        &#125;    6.IOS下取消input输入框在输入引文首字母默认大写        &lt;input autocapitalize=&#39;off&#39; autocorrect=&#39;off&#39;/&gt;    7.禁用IOS和安卓用户选中文字        添加全局CSS样式：-webkit-user-select:none    8.禁止IOS弹出各种窗口        -webkit-touch-callout:none    9.禁止IOS识别长串数字为电话        添加meta属性 &lt;meta conten=&#39;telephone=no&#39; name=&#39;format-detection&#39;&gt;</code></pre><h3 id="四、Vue"><a href="#四、Vue" class="headerlink" title="四、Vue"></a>四、Vue</h3><h5 id="1-v-if和v-show的区别？"><a href="#1-v-if和v-show的区别？" class="headerlink" title="1.v-if和v-show的区别？"></a>1.v-if和v-show的区别？</h5><pre><code>    都可以控制元素的显示和隐藏    1.v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除    2.v-if有一个局部编译/卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换    3.v-if才是真正的条件渲染；v-show从false变成true的时候不会触发组件的生命周期，v-if会触发生命周期    4.v-if的切换效率比较低  v-show的效率比较高</code></pre><h5 id="2-如何理解MVVM的？"><a href="#2-如何理解MVVM的？" class="headerlink" title="2.如何理解MVVM的？"></a>2.如何理解MVVM的？</h5><pre><code>    是Model-View-ViewModel的缩写。前端开发的架构模式    M：模型，对应的就是data的数据    V：视图，用户界面，DOM    VM：视图模型：Vue的实例对象，连接View和Model的桥梁    核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定    ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理</code></pre><h5 id="3-v-for中的key值的作用是什么？"><a href="#3-v-for中的key值的作用是什么？" class="headerlink" title="3.v-for中的key值的作用是什么？"></a>3.v-for中的key值的作用是什么？</h5><pre><code>    key属性是DOM元素的唯一标识    作用：        1.提高虚拟DOM的更新        2.若不设置key，可能会触发一些bug        3.为了触发过度效果</code></pre><h5 id="4-说一下你对vue生命周期的理解。"><a href="#4-说一下你对vue生命周期的理解。" class="headerlink" title="4.说一下你对vue生命周期的理解。"></a>4.说一下你对vue生命周期的理解。</h5><p>  组件实例化之后(打开页面)执行的生命周期是创建和挂载<br>        组件从创建到销毁的过程就是它的生命周期<br>        setup相当于beforeCreat+Created,剩下的周期与Vue3一致<br>        创建 可调用$data<br>            beforeCreat<br>                在这个阶段属性和方法都不能使用<br>            created<br>                这里时实例创建完成之后，在这里完成了数据监测，<code>可以使用数据</code>，修改数据，不会触发updated，也不会更新视图<br>        挂载 可调用dom $el即实例化对象<br>            beforeMount<br>                完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated<br>            Mounted<br>                把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点<br>        更新<br>            beforeUpdate<br>                组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据<br>            updated<br>                render重新做了渲染，这时数据和页面都是新的，避免在此更新数据<br>        销毁（Vue3中替换为beforeUnMount和UnMounted）<br>            beforeDestroy<br>                实例销毁前，在这里实例还可以用，可以清楚定时器等等<br>            destroyed<br>                组件已经被销毁了，全部都销毁<br>        使用了keep-alive时多出两个周期：<br>            activited<br>                组件激活时<br>            deactivited<br>                组件被销毁时</p><h5 id="5-在created和mounted去请求数据，有什么区别？"><a href="#5-在created和mounted去请求数据，有什么区别？" class="headerlink" title="5.在created和mounted去请求数据，有什么区别？"></a>5.在created和mounted去请求数据，有什么区别？</h5><pre><code>    created：在渲染前调用，通常先初始化属性，然后做渲染    mounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作            在这里请求数据可能会出现闪屏的问题，created里不会    一般用created比较多    请求的数据对DOM有影响，那么使用created    如果请求的数据对DOM无关，可以放在mounted</code></pre><h5 id="6-vue中的修饰符有哪些？"><a href="#6-vue中的修饰符有哪些？" class="headerlink" title="6.vue中的修饰符有哪些？"></a>6.vue中的修饰符有哪些？</h5><pre><code>    1.事件修饰符        .stop       组织冒泡        .prevent    组织默认行为        .capture    内部元素触发的事件先在次处理        .self       只有在event.target是当前元素时触发        .once       事件只会触发一次        .passive    立即触发默认行为        .native     把当前元素作为原生标签看待    2.按键修饰符        .keyup      键盘抬起        .keydown    键盘按下    3.系统修饰符        .ctrl        .alt        .meta    4.鼠标修饰符        .left       鼠标左键        .right      鼠标右键        .middle     鼠标中键    5.表单修饰符        .lazy       等输入完之后再显示        .trim       删除内容前后的空格        .number     输入是数字或转为数字</code></pre><h5 id="7-elementui是怎么做表单验证的？"><a href="#7-elementui是怎么做表单验证的？" class="headerlink" title="7.elementui是怎么做表单验证的？"></a>7.elementui是怎么做表单验证的？</h5><pre><code>    1.在表单中加rules属性，然后再data里写校验规则    2.内部添加规则    3.自定义函数校验</code></pre><h5 id="8-vue如何进行组件通信？"><a href="#8-vue如何进行组件通信？" class="headerlink" title="8.vue如何进行组件通信？"></a>8.vue如何进行组件通信？</h5><pre><code>    1.父传子        props            父组件使用自定义属性，然后子组件使用props        $ref            引用信息会注册在父组件的$refs对象上    2.子传父        $emit            子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数    3.兄弟传        new一个新的vue实例，用on和emit来对数据进行传输    4.vuex传值</code></pre><h5 id="9-keep-alive是什么？怎么使用？"><a href="#9-keep-alive是什么？怎么使用？" class="headerlink" title="9.keep-alive是什么？怎么使用？"></a>9.keep-alive是什么？怎么使用？</h5><pre><code>    Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们    作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验</code></pre><h5 id="10-axios是怎么做封装的？"><a href="#10-axios是怎么做封装的？" class="headerlink" title="10.axios是怎么做封装的？"></a>10.axios是怎么做封装的？</h5><pre><code>    下载 创建实例 接着封装请求响应拦截器  抛出 最后封装接口</code></pre><h5 id="11-vue路由时怎么传参的？"><a href="#11-vue路由时怎么传参的？" class="headerlink" title="11.vue路由时怎么传参的？"></a>11.vue路由时怎么传参的？</h5><pre><code>    params传参        this.$router.push(&#123;name:&#39;index&#39;,params:&#123;id:item.id&#125;&#125;)        this.$route.params.id    路由属性传参        this.$router.push(&#123;name:&#39;/index/$&#123;item.id&#125;&#39;&#125;)        路由配置 &#123; path:&#39;/index:id&#39; &#125;    query传参（可以解决页面刷新参数丢失的问题）        this.$router.push(&#123;            name:&#39;index&#39;,            query:&#123;id:item.id&#125;        &#125;)</code></pre><h5 id="12-vue路由的hash模式和history模式有什么区别？"><a href="#12-vue路由的hash模式和history模式有什么区别？" class="headerlink" title="12.vue路由的hash模式和history模式有什么区别？"></a>12.vue路由的hash模式和history模式有什么区别？</h5><pre><code>    1.hash的路由地址上有#号，history模式没有    2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404    3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API    4.hash不会重新加载页面，单页面应用必备    5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求    6.history需要后台配置</code></pre><h5 id="13-路由拦截是怎么实现的？"><a href="#13-路由拦截是怎么实现的？" class="headerlink" title="13.路由拦截是怎么实现的？"></a>13.路由拦截是怎么实现的？</h5><pre><code>    路由拦截 axios拦截    需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截    &#123;        name:&#39;index&#39;,        path:&#39;/index&#39;,        component:Index,        meta:&#123;            requirtAuth:true        &#125;    &#125;    router.beforeEach((to,from,next) =&gt; &#123;        if(to.meta.requirtAuth)&#123;            if( store.satte.token )&#123;                next()            &#125;else&#123;                            &#125;        &#125;    &#125;)</code></pre><h5 id="14-说一下vue的动态路由。"><a href="#14-说一下vue的动态路由。" class="headerlink" title="14.说一下vue的动态路由。"></a>14.说一下vue的动态路由。</h5><pre><code>    要在路由配置里设置meat属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转    根据用户登录的账号，返回用户角色    前端再根据角色，跟路由表的meta.role进行匹配    把匹配搭配的路由形成可访问的路由</code></pre><h5 id="15-如何解决刷新后二次加载路由？"><a href="#15-如何解决刷新后二次加载路由？" class="headerlink" title="15.如何解决刷新后二次加载路由？"></a>15.如何解决刷新后二次加载路由？</h5><pre><code>    1.window.location.reload()    2.matcher        const router = createRouter()        export function resetRouter()&#123;            const newRouter = creatRouter()            router.matcher = newRouter.matcher        &#125;</code></pre><h5 id="16-vuex刷新数据会丢失吗？怎么解决？"><a href="#16-vuex刷新数据会丢失吗？怎么解决？" class="headerlink" title="16.vuex刷新数据会丢失吗？怎么解决？"></a>16.vuex刷新数据会丢失吗？怎么解决？</h5><pre><code>    vuex肯定会重新获取数据，页面也会丢失数据    1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）    2.页面刷新的时候，再次请求数据，达到可以动态更新的方法        监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据</code></pre><h5 id="17-computed和watch的区别？"><a href="#17-computed和watch的区别？" class="headerlink" title="17.computed和watch的区别？"></a>17.computed和watch的区别？</h5><pre><code>    1.computed是计算属性，watch是监听，监听的是data中数据的变化    2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存    3.computed不支持异步，watch是可以异步操作    4.computed是第一次加载就监听，watch是不监听    5.computed函数中必须有return  watch不用</code></pre><h5 id="18-vuex在什么场景会去使用？属性有哪些？"><a href="#18-vuex在什么场景会去使用？属性有哪些？" class="headerlink" title="18.vuex在什么场景会去使用？属性有哪些？"></a>18.vuex在什么场景会去使用？属性有哪些？</h5><pre><code>    state       存储变量    getters     state的计算属性    mutations   提交更新数据的方法    actions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作    modules     模块化vuex    使用场景：        用户的个人信息、购物车模块、订单模块</code></pre><h5 id="19-vue的双向数据绑定原理是什么？"><a href="#19-vue的双向数据绑定原理是什么？" class="headerlink" title="19.vue的双向数据绑定原理是什么？"></a>19.vue的双向数据绑定原理是什么？</h5><pre><code>    通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，    在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图时同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。    第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter    第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图    第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：            1.在自身实例化的时候忘订阅器内添加自己            2.自身要有一个update()方法            3.等待属性变动时，调用自身的update方法，触发compile这种的回调    第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果</code></pre><h5 id="20-了解diff算法和虚拟DOM吗？"><a href="#20-了解diff算法和虚拟DOM吗？" class="headerlink" title="20.了解diff算法和虚拟DOM吗？"></a>20.了解diff算法和虚拟DOM吗？</h5><pre><code>    虚拟DOM，描述元素和元素之间的关系，创建一个JS对象    如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改    diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM    步骤：        1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面        2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异        3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。</code></pre><h5 id="21-vue和jquery的区别是什么？"><a href="#21-vue和jquery的区别是什么？" class="headerlink" title="21.vue和jquery的区别是什么？"></a>21.vue和jquery的区别是什么？</h5><pre><code>    1.原理不同        vue就是数据绑定；jq是先获取dom再处理    2.着重点不同        vue是数据驱动，jq是着重于页面    3.操作不同    4.未来发展不同</code></pre><h5 id="22-vuex的响应式处理。"><a href="#22-vuex的响应式处理。" class="headerlink" title="22.vuex的响应式处理。"></a>22.vuex的响应式处理。</h5><pre><code>    vuex是vue的状态管理工具    vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图    Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。    vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中</code></pre><h5 id="23-vue中遍历全局的方法有哪些？"><a href="#23-vue中遍历全局的方法有哪些？" class="headerlink" title="23.vue中遍历全局的方法有哪些？"></a>23.vue中遍历全局的方法有哪些？</h5><pre><code>    1.普通遍历，对象.forEach()        arr.forEach(function(item,index,arr)&#123;            console.log(item,index)        &#125;)    2.对元素统一操作  对象.map()        var newarr = arr.map(function(item)&#123;            return item+1        &#125;)    3.查找符合条件的元素 对象.filter()        arr.filter(function(item)&#123;            if(item &gt; 2)&#123;                return false            &#125;else&#123;                return true            &#125;        &#125;)    4.查询符合条件的元素，返回索引 对象.findindex()        arr.finindex(function(item)&#123;            if(item&gt;1)&#123;                return true            &#125;else&#123;                return false            &#125;        &#125;)    对象.evening()  遇到不符合的对象会停止    对象.some()  找到符合条件的元素就停止</code></pre><h5 id="24-如何搭建脚手架？"><a href="#24-如何搭建脚手架？" class="headerlink" title="24.如何搭建脚手架？"></a>24.如何搭建脚手架？</h5><pre><code>    下载：node  cnpm  webpack vue-cli    创建项目：        1.找到对应的文件，然后利用node指令创建（cmd）        2.vue init webpack xxxx        3.回车项目描述        4.作者回车        5.选择vue build        6.回车        7.输入n        8.不按照yarn        9.输入npm run dev</code></pre><h5 id="25-如何封装一个组件？"><a href="#25-如何封装一个组件？" class="headerlink" title="25.如何封装一个组件？"></a>25.如何封装一个组件？</h5><pre><code>    1.使用Vue.extend()创建一个组件    2.使用Vue.components()方法注册组件    3.如果子组件需要数据，可以在props中接收定义    4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法    原则：        把功能拆开        尽量让组件原子化，一个组件做一件事情        容器组件管数据，展示组件管视图</code></pre><h5 id="26-封装一个可复用的组件，需要满足什么条件？"><a href="#26-封装一个可复用的组件，需要满足什么条件？" class="headerlink" title="26.封装一个可复用的组件，需要满足什么条件？"></a>26.封装一个可复用的组件，需要满足什么条件？</h5><pre><code>    1.低耦合，组件之间的依赖越小越好    2.最好从父级传入信息，不要在公共组件中请求数据    3.传入的数据要进行校验    4.处理事件的方法写在父组件中</code></pre><h5 id="27-vue的过滤器怎么使用？"><a href="#27-vue的过滤器怎么使用？" class="headerlink" title="27.vue的过滤器怎么使用？"></a>27.vue的过滤器怎么使用？</h5><pre><code>    vue的特性，用来对文本进行格式化处理    使用它的两个地方，一个是插值表达式，一个是v-bind    分类：        1.全局过滤器            Vue.filter(&#39;add&#39;,function(v)&#123;                return v &lt; 10 ? &#39;0&#39; + v : v            &#125;)            &lt;div&gt;&#123;&#123;33 | add&#125;&#125;&lt;/div&gt;        2.本地过滤器            和methods同级            filter:&#123;                add:function(v)&#123;                    return v &lt; 10 ? &#39;0&#39; + v : v                &#125;            &#125;</code></pre><h5 id="28-vue中如何做强制刷新？"><a href="#28-vue中如何做强制刷新？" class="headerlink" title="28.vue中如何做强制刷新？"></a>28.vue中如何做强制刷新？</h5><pre><code>    1.localtion.reload()    2.this.$router.go(0)    3.provide和inject</code></pre><h5 id="29-vue3和vue2有哪些区别？"><a href="#29-vue3和vue2有哪些区别？" class="headerlink" title="29.vue3和vue2有哪些区别？"></a>29.vue3和vue2有哪些区别？</h5><pre><code>    1.双向数据绑定的原理不同  Object.defineproperty/proxy    2.是否支持碎片    3.API不同    4.定义数据变量方法不同    5.生命周期的不同     销毁destoryed/UnMounted    6.传值不同    7.指令和插槽不同    8.main.js不同</code></pre><h5 id="30-vue的性能优化怎么做？"><a href="#30-vue的性能优化怎么做？" class="headerlink" title="30.vue的性能优化怎么做？"></a>30.vue的性能优化怎么做？</h5><pre><code>    1.编码优化        不要把所有数据都放在data中        v-for时给每个元素绑定事件用事件代理        keep-alive缓存组件        尽可能拆分组件，提高复用性、维护性        key值要保证唯一        合理使用路由懒加载，异步组件        数据持久化存储的使用尽量用防抖、节流优化    2.加载优化        按需加载        内容懒加载        图片懒加载    3.用户体验        骨架屏    4.SEO优化        预渲染        服务端渲染ssr    5.打包优化        CDN形式加载第三方模块        多线程打包        抽离公共文件    6.缓存和压缩        客户端缓存、服务端缓存        服务端Gzip压缩</code></pre><h5 id="31-首屏优化该如何去做？"><a href="#31-首屏优化该如何去做？" class="headerlink" title="31.首屏优化该如何去做？"></a>31.首屏优化该如何去做？</h5><pre><code>    1.使用路由懒加载    2.非首屏组件使用异步组件    3.首屏不中要的组件延迟加载    4.静态资源放在CDN上    5.减少首屏上JS、CSS等资源文件的大小    6.使用服务端渲染    7.简历减少DOM的数量和层级    8.使用精灵图请求    9.做一些loading    10.开启Gzip压缩    11.图片懒加载</code></pre><h5 id="32-vue3的性能为什么比vue2好？"><a href="#32-vue3的性能为什么比vue2好？" class="headerlink" title="32.vue3的性能为什么比vue2好？"></a>32.vue3的性能为什么比vue2好？</h5><pre><code>    1.diff算法的优化    2.静态提升    3.事件侦听缓存</code></pre><h5 id="33-vue3为什么使用proxy？"><a href="#33-vue3为什么使用proxy？" class="headerlink" title="33.vue3为什么使用proxy？"></a>33.vue3为什么使用proxy？</h5><pre><code>    defineproperty监听对象时需遍历所有属性，才能劫持对象并进行读写。    proxy监听整个对象无需遍历。    1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性    2.proxy对代理对象的监听更加丰富    3.proxy代理对象会生成新的对象，不会修改被代理对象本身    4.proxy补兼容ie浏览器</code></pre><h5 id="34-说一下你对组件的理解。"><a href="#34-说一下你对组件的理解。" class="headerlink" title="34.说一下你对组件的理解。"></a>34.说一下你对组件的理解。</h5><pre><code>    可以重复使用的vue实例，独一无二的组件名称    可以抽离单独的公共模块    提高代码的复用率</code></pre><h5 id="35-你是如何规划项目文件的？"><a href="#35-你是如何规划项目文件的？" class="headerlink" title="35.你是如何规划项目文件的？"></a>35.你是如何规划项目文件的？</h5><pre><code>    public        图标、index.html、img    src        api        assets        components            按分类再次划分子目录        plugins        router        static        styles        utils        views    App.vue    main.js    package.json    vue.config.js</code></pre><h5 id="36-是否使用过nuxt-js？"><a href="#36-是否使用过nuxt-js？" class="headerlink" title="36.是否使用过nuxt.js？"></a>36.是否使用过nuxt.js？</h5><pre><code>    是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置    SSR：服务端渲染        好处：            SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索            优化了首屏加载时间    SEO：优化搜索引擎    SPA的应用不利于搜索引擎SEO的操作</code></pre><h5 id="37-SEO如何优化？"><a href="#37-SEO如何优化？" class="headerlink" title="37.SEO如何优化？"></a>37.SEO如何优化？</h5><pre><code>    1.SSR    2.预渲染 prerender-spa-plugin</code></pre><h3 id="五、Echarts"><a href="#五、Echarts" class="headerlink" title="五、Echarts"></a>五、Echarts</h3><h5 id="1-echarts有用过吗？常用的组件有哪些？"><a href="#1-echarts有用过吗？常用的组件有哪些？" class="headerlink" title="1.echarts有用过吗？常用的组件有哪些？"></a>1.echarts有用过吗？常用的组件有哪些？</h5><pre><code>    title标题组件 show  text  link    toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature    tooltip tigger 触发类型    markPoint标注点    markLine图标的标线</code></pre><h3 id="六、Uni-APP"><a href="#六、Uni-APP" class="headerlink" title="六、Uni-APP"></a>六、Uni-APP</h3><h5 id="1-uni-app有没有做过分包？"><a href="#1-uni-app有没有做过分包？" class="headerlink" title="1.uni-app有没有做过分包？"></a>1.uni-app有没有做过分包？</h5><pre><code>    优化小程序的下载和启动速度    小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示</code></pre><h3 id="七、Weabpack"><a href="#七、Weabpack" class="headerlink" title="七、Weabpack"></a>七、Weabpack</h3><h5 id="1-webpack打包和不打包的区别？"><a href="#1-webpack打包和不打包的区别？" class="headerlink" title="1.webpack打包和不打包的区别？"></a>1.webpack打包和不打包的区别？</h5><pre><code>    1.运行效率    2.对基础的支持不够</code></pre><h5 id="2-webpack是怎么打包的，babel是做什么的？"><a href="#2-webpack是怎么打包的，babel是做什么的？" class="headerlink" title="2.webpack是怎么打包的，babel是做什么的？"></a>2.webpack是怎么打包的，babel是做什么的？</h5><pre><code>    webpack会把js css image看作一个模块，用import/require引入    找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起    把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件    如果一个被多个文件引用，打包时只会生成一个文件    如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包    对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中</code></pre><h3 id="八、Git"><a href="#八、Git" class="headerlink" title="八、Git"></a>八、Git</h3><h5 id="1-git如何合并、拉取代码？"><a href="#1-git如何合并、拉取代码？" class="headerlink" title="1.git如何合并、拉取代码？"></a>1.git如何合并、拉取代码？</h5><pre><code>    拉取代码 git pull &#39;仓库地址&#39;    查看状态 git sattus     提交到本地缓存区  git add .    提交本地仓库 git commit -m &#39;修改描述&#39;    提交到远程仓库 git push &#39;仓库地址&#39; master    创建分支 git branch -b xxx    合并分支 git merge &#39;合并分支的名字&#39;</code></pre><h5 id="2-git如何解决冲突问题？"><a href="#2-git如何解决冲突问题？" class="headerlink" title="2.git如何解决冲突问题？"></a>2.git如何解决冲突问题？</h5><pre><code>    1.两个分支中修改了同一个文件    2.两个分支中修改了同一个文件的名字    1.解决：当前分支上，直接修改代码  add  commit    2.解决：在本地当前分支上，修改冲突代码 add commit push</code></pre><h3 id="九、HR"><a href="#九、HR" class="headerlink" title="九、HR"></a>九、HR</h3><h5 id="1-你的离职原因是什么？"><a href="#1-你的离职原因是什么？" class="headerlink" title="1.你的离职原因是什么？"></a>1.你的离职原因是什么？</h5><pre><code>    疫情 社保 薪资问题 个人发展 技术提升 家庭因素</code></pre><h5 id="2-工作到现在，项目中遇到最难的问题是什么？怎么解决的？"><a href="#2-工作到现在，项目中遇到最难的问题是什么？怎么解决的？" class="headerlink" title="2.工作到现在，项目中遇到最难的问题是什么？怎么解决的？"></a>2.工作到现在，项目中遇到最难的问题是什么？怎么解决的？</h5><pre><code>    1.不要回答，没有问题    2.不要说一些常见的简单的问题，比如：数据请求不过来、渲染页面时出现了问题、跳转路由不会...    首先应该时自行去查找资料寻求解决办法，然后再去请教同时或者组长</code></pre><h5 id="3-你的优势在哪里？"><a href="#3-你的优势在哪里？" class="headerlink" title="3.你的优势在哪里？"></a>3.你的优势在哪里？</h5><pre><code>    1.尽量不要暴露自己的缺点    2.不要过度美化自己</code></pre><h5 id="4-如何协同工作？"><a href="#4-如何协同工作？" class="headerlink" title="4.如何协同工作？"></a>4.如何协同工作？</h5><pre><code>    1.开发前会开个会议，最后形成一个开发文档    2.利用工具保证项目的正常进度，规范化</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>零零碎碎</title>
      <link href="/2024/02/14/%E5%85%AB%E8%82%A1%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/02/14/%E5%85%AB%E8%82%A1%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h3><h3 id="请求组成"><a href="#请求组成" class="headerlink" title="请求组成"></a>请求组成</h3><h3 id="浏览器给服务器发送数据都是啥"><a href="#浏览器给服务器发送数据都是啥" class="headerlink" title="浏览器给服务器发送数据都是啥"></a>浏览器给服务器发送数据都是啥</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切换不同环境的api</title>
      <link href="/2023/12/26/%E5%BC%80%E5%8F%91%E5%88%87%E6%8D%A2api/"/>
      <url>/2023/12/26/%E5%BC%80%E5%8F%91%E5%88%87%E6%8D%A2api/</url>
      
        <content type="html"><![CDATA[<h3 id="request-js中关于api的切换的内容"><a href="#request-js中关于api的切换的内容" class="headerlink" title="request.js中关于api的切换的内容"></a>request.js中关于api的切换的内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function request(options) &#123;</span><br><span class="line">  options.method = options.method || &quot;get&quot;;</span><br><span class="line">  //关于get请求参数调整</span><br><span class="line">  if (options.method.toLowerCase() === &quot;get&quot;) &#123;</span><br><span class="line">    options.params = options.data;</span><br><span class="line">  &#125;</span><br><span class="line">  //对mock开关进行处理</span><br><span class="line">  let isMock = config.mock;</span><br><span class="line">  </span><br><span class="line">  if (typeof options.isMock !== &quot;undefined&quot;) &#123;//确保传入</span><br><span class="line">    isMock = options.mock;</span><br><span class="line">  &#125;</span><br><span class="line">  //针对环境进行处理</span><br><span class="line">  if (config.env === &#x27;prod&#x27;) &#123;</span><br><span class="line">    service.defaults.baseURL = config.baseApi;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    service.defaults.baseURL = isMock ? config.mockApi : config.baseApi;</span><br><span class="line">  &#125;</span><br><span class="line">  return service(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="config-js内容"><a href="#config-js内容" class="headerlink" title="config.js内容"></a>config.js内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const env = import.meta.env.MODE || &quot;prod&quot;; </span><br><span class="line">const EnvConfig = &#123;</span><br><span class="line">  development: &#123;  //开发板</span><br><span class="line">    baseApi: &#x27;api&#x27;,//本地的api文件内容</span><br><span class="line">    mockApi: &quot;https://apifoxmock.com/m1/4068509-0-default/api&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  test: &#123;   // 测试版</span><br><span class="line">    baseApi: &#x27;//test.future.com/api&#x27;,</span><br><span class="line">    mockApi: &quot;https://apifoxmock.com/m1/4068509-0-default/api&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  prod: &#123; //上线版</span><br><span class="line">    baseApi: &#x27;//future.com/api&#x27;,</span><br><span class="line">    mockApi: &quot;https://apifoxmock.com/m1/4068509-0-default/api&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">export default &#123;</span><br><span class="line">  env,</span><br><span class="line">  ...EnvConfig[env],</span><br><span class="line">  //mock</span><br><span class="line">  mock:false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getTableData() &#123;</span><br><span class="line">    return request(&#123;</span><br><span class="line">      url: &quot;/home/getTableData&quot;,</span><br><span class="line">      method: &quot;get&quot;,</span><br><span class="line">      // mock:false, //单独管理数据来源</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全景图基础</title>
      <link href="/2023/08/14/photo-sphere-viewer%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
      <url>/2023/08/14/photo-sphere-viewer%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="photo-sphere-viewer中文文档"><a href="#photo-sphere-viewer中文文档" class="headerlink" title="photo-sphere-viewer中文文档"></a>photo-sphere-viewer中文文档</h3><p><a href="https://chenjianhong.blog.csdn.net/article/details/122243459?spm=1001.2014.3001.5502">https://chenjianhong.blog.csdn.net/article/details/122243459?spm=1001.2014.3001.5502</a></p><h3 id="博客上传时遇到443问题"><a href="#博客上传时遇到443问题" class="headerlink" title="博客上传时遇到443问题"></a>博客上传时遇到443问题</h3><p>可以通过关闭防火墙解决</p>]]></content>
      
      
      
        <tags>
            
            <tag> photo-sphere-viewer组件 </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础2</title>
      <link href="/2023/06/13/v-if%E4%B8%8Ev-show/"/>
      <url>/2023/06/13/v-if%E4%B8%8Ev-show/</url>
      
        <content type="html"><![CDATA[<h3 id="v-if与v-show"><a href="#v-if与v-show" class="headerlink" title="v-if与v-show"></a>v-if与v-show</h3><p>v-show会把元素css改变（display：none），主用于频繁显示隐藏，（对性能要求高可以用。）</p><p>v-if会把元素变成注释节点，操作dom</p><p>ref和relactive可以把值变成响应式的</p><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>NaN全称是Not a Number就是元素不是数字类型</p><p>NaN与<strong>任何值</strong>相加都会得到NaN</p><p>与<strong>任何值</strong>都<strong>不相等</strong></p><p>isNaN()：<code>会先尝试转换为数字</code>，若无法转换为数字，就返回true，否则返回false</p><p>Number.isNaN():直接检查元素是不是NaN</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          console.log(NaN===NaN);//false</span><br><span class="line">          </span><br><span class="line">          console.log(isNaN(5));//false</span><br><span class="line"></span><br><span class="line">​            console.log(isNaN(&#x27;5&#x27;));//false</span><br><span class="line"></span><br><span class="line">​            console.log(isNaN(&#x27;apple&#x27;));//true</span><br><span class="line"></span><br><span class="line">​            console.log(Number.isNaN(NaN));//true</span><br><span class="line"></span><br><span class="line">​            console.log(Number.isNaN(5));//false</span><br><span class="line"></span><br><span class="line">​            console.log(Number.isNaN(&#x27;5&#x27;));//false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符与关键词</title>
      <link href="/2023/06/11/%E5%85%AB%E8%82%A1js/"/>
      <url>/2023/06/11/%E5%85%AB%E8%82%A1js/</url>
      
        <content type="html"><![CDATA[<h3 id="运算符“-”和“-”异同"><a href="#运算符“-”和“-”异同" class="headerlink" title="运算符“&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”异同"></a>运算符“&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”异同</h3><p>“&#x3D;&#x3D;”是比较运算符，计算机可以帮助转换成同类型的进行比较。</p><ol><li>null和undefined: null和undefined仅相等于自身和对方。在转为布尔值时都为false</li><li>原始类型比较（字符串、数字、布尔值）都会转化成数字比较。其中空字符串会转变为数字0.</li><li>对象和原始类型:如果有一个操作数是对象，另一个是原始类型（字符串、数字、布尔值），会调用调用toPrimitive方法(valueOf或toString)，转换为原始类型后再比较。</li><li>符号和其他类型: Symbol类型只能与Symbol类型进行比较，与其他类型的比较总是返回false.</li></ol><p>“&#x3D;&#x3D;&#x3D;”（全等于&#x2F;绝对等于）也是比较运算符，但是计算机不会帮助进行类型转换。它不进行类型转换，仅在值和类型都相等时才返回true 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        let a=6;    //typeof Number</span><br><span class="line">        let c=&#x27;6&#x27;;  //typeof String</span><br><span class="line"></span><br><span class="line">​        console.log(a==c);  //true</span><br><span class="line"></span><br><span class="line">​        console.log(a === c);   //false</span><br></pre></td></tr></table></figure><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>首先设置表达式 <em>n</em>（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较。如果存在匹配，则与该 case 关联的代码块会被执行。请使用 <strong>break</strong> 来阻止代码自动地向下一个 case 运行。如果都没有break，那么就会把case语句中都执行然后到default再退出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        switch (n) &#123;</span><br><span class="line"></span><br><span class="line">​                case 1:</span><br><span class="line"></span><br><span class="line">​        执行代码块 1</span><br><span class="line"></span><br><span class="line">​                    break;</span><br><span class="line"></span><br><span class="line">​                case 2:</span><br><span class="line"></span><br><span class="line">​        执行代码块 2</span><br><span class="line"></span><br><span class="line">​                    break;</span><br><span class="line"></span><br><span class="line">​                default:</span><br><span class="line"></span><br><span class="line">​        与 case 1 和 case 2 不同时执行的代码</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br></pre></td></tr></table></figure><p>while 循环会在指定条件为真时循环执行代码块。</p><p>do&#x2F;while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。该循环至少会执行一次，即使条件为 false 它也会执行一次，因为代码块会在条件被测试前执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function star(row = 5) &#123;</span><br><span class="line"></span><br><span class="line">​            let start = 0;</span><br><span class="line"></span><br><span class="line">​            do &#123;</span><br><span class="line"></span><br><span class="line">​                let n = 0;</span><br><span class="line"></span><br><span class="line">​                do &#123;</span><br><span class="line"></span><br><span class="line">​                    document.write(&#x27;*&#x27;);</span><br><span class="line"></span><br><span class="line">​                &#125; while (++n &lt;= start);</span><br><span class="line"></span><br><span class="line">​                document.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line"></span><br><span class="line">​            &#125; while (++start &lt;= row);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        star();</span><br></pre></td></tr></table></figure><p>for循环打印杨辉三角</p><p><img src="/../img/sanjiao.jpg" alt="杨辉三角"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function sanjiao(row = 5) &#123;</span><br><span class="line"></span><br><span class="line">​            for (let i = 1; i &lt; row; i++) &#123; //控制行数</span><br><span class="line"></span><br><span class="line">​                for (let n = row - i; n &gt; 0; n--) &#123;</span><br><span class="line"></span><br><span class="line">​                    document.write(&quot;^&quot;);//先打印出空白区域</span><br><span class="line"></span><br><span class="line">​                &#125;</span><br><span class="line"></span><br><span class="line">​                for (let m = i * 2 - 1; m &gt; 0; m--) &#123;</span><br><span class="line"></span><br><span class="line">​                    document.write(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">​                &#125;</span><br><span class="line"></span><br><span class="line">​                document.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        sanjiao(5);</span><br></pre></td></tr></table></figure><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><p>基本：string number  boolean undefined null <code>symbol bigint(大数) es6新增</code><br>保存在栈内存，保存基本的值。<br>引用（复杂）：function array object<br>保存在堆内存，保存的是引用类型数据的地址。<br><code>instanceof</code>能够详细区分数组属性和对象属性。但是对基本数据类型不管用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log([] instanceof Array) //true</span><br><span class="line">console.log(&#x27;abc&#x27; instanceof String) //false</span><br></pre></td></tr></table></figure><p><code>typeof</code>检测null和数组和对象都是object（包括普通对象、数组、函数）。可以检测出函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof []) //Object</span><br><span class="line">console.log(typeof &#x27;abc&#x27;) //String</span><br></pre></td></tr></table></figure><p><code>construtor</code> 几乎可以判断基本和引用数据类型，但是当声明构造函数并把原型指向array无法判断</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log((&#x27;abc&#x27;).construtor===String ) //true</span><br></pre></td></tr></table></figure><p><code>Object.prototype.toString.call()</code>; 可以检测所有数据类型.</p><p>pro&#x2F;to&#x2F;type<br>\为转义符号，可以更改符号的意义使其正常输出。</p><h3 id="字符串的连接"><a href="#字符串的连接" class="headerlink" title="字符串的连接"></a>字符串的连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let year=&quot;2008&quot;;</span><br><span class="line">let month=&quot;11&quot;;</span><br><span class="line">let su= `$&#123;year&#125;年$&#123;month&#125;是很难忘的日期`;</span><br><span class="line">console.log(year+&quot;年&quot;+month+&quot;是很难忘的日期&quot;);</span><br><span class="line"></span><br><span class="line">console.log(`$&#123;year&#125;年$&#123;month&#125;是很难忘的日期`);</span><br><span class="line"></span><br><span class="line">console.log(su);</span><br></pre></td></tr></table></figure><p>输出结果一致，更推荐使用第二种。即使用··进行字符串的连接。</p><h3 id="封装获取日期函数"><a href="#封装获取日期函数" class="headerlink" title="封装获取日期函数"></a>封装获取日期函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const date = new Date();</span><br><span class="line"></span><br><span class="line">function dateFormat(date,format=&quot;YYYY-MM-DD hh:mm:ss&quot;)&#123;</span><br><span class="line">        const config=&#123;</span><br><span class="line">                YYYY:date.getFullYear();</span><br><span class="line">                MM:date.getMonth() + 1;// 月份从0开始，需要加1</span><br><span class="line">                DD:date.getDate();</span><br><span class="line">                hh:date.getHours();</span><br><span class="line">                mm:date.getMinutes();</span><br><span class="line">                ss:date.getSeconds();</span><br><span class="line">        &#125;;</span><br><span class="line">        for(const key in config)&#123;</span><br><span class="line">                format=format.replace(key,config[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        return format;</span><br><span class="line">&#125;</span><br><span class="line">console.log(dateFormat(date,&#x27;YYYY年MM月DD日&#x27;));//后面可以更改格式，否则是上方的默认格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>函数嵌套函数，内部函数被外部函数返回并保存下来就会产生闭包。</p><p>特点：可重复利用变量，且不会污染全局。该变量是一直保存在内存中，不会被垃圾回收机制回收。</p><p>缺点：闭包较多时，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄漏。<br>场景：防抖节流 函数嵌套函数避免污染</p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>原因：过度的闭包，未被清除的定时器和引用元素，<br>内存已经被分配，长时间没有释放或者清楚，导致长时间占用内存，资源浪费。导致运行速度慢，甚至崩溃。<br>解决：垃圾回收机制。</p><h3 id="事件委托（代理）"><a href="#事件委托（代理）" class="headerlink" title="事件委托（代理）"></a>事件委托（代理）</h3><p>就是利用<code>事件冒泡机制</code>将子元素事件交给父元素来触发，可减少绑定次数（提高性能），可动态添加和删除（方便维护）<br>子元素阻止事件冒泡，委托不成立。<br>event.stopPropagation(); &#x2F;&#x2F;阻止事件传播即导致事件冒泡和捕获都停止<br>addEventListener(‘click’,函数名,true&#x2F;false)默认为false(事件冒泡)，true(事件捕获);</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础</title>
      <link href="/2023/06/10/js%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/06/10/js%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="javascript变量的生命周期"><a href="#javascript变量的生命周期" class="headerlink" title="javascript变量的生命周期"></a>javascript变量的生命周期</h4><p>JavaScript 变量生命周期在它声明时初始化。</p><p>局部变量在函数执行完毕后销毁。</p><p>全局变量在页面关闭后销毁。</p><p>var会污染window变量。</p><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>由于var定义变量会有变量提升（声明会提升但是不会提升初始化赋值），因此let和const定义变量比较好。</p><p>var支持先使用再赋值。剩余两者必须先声明再使用（很好的习惯）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        console.log(a);</span><br><span class="line">​        var a = &#x27;111&#x27;;</span><br></pre></td></tr></table></figure><p>后台提示undefined。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            console.log(a);</span><br><span class="line">​            let a = &#x27;111&#x27;;</span><br></pre></td></tr></table></figure><p>后台提示Uncaught ReferenceError: Cannot access ‘a’ before initialization</p><p>下面例子表明先声明再使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function sun(a=b,b=3)&#123;&#125;</span><br><span class="line">​        sun();</span><br></pre></td></tr></table></figure><p>后台提示ReferenceError: Cannot access ‘b’ before initialization</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function sun(a=3,b=a)&#123;&#125;</span><br><span class="line">​        sun();</span><br></pre></td></tr></table></figure><p>此时a&#x3D;b&#x3D;3</p><h4 id="var和let的区别"><a href="#var和let的区别" class="headerlink" title="var和let的区别"></a>var和let的区别</h4><p>全局作用域下var定义的变量会被挂载到window上，let不会被挂载到window上。</p><p>var没块级作用域，let有。</p><p>var可以重复声明（相当于window上的对象进行重新赋值），剩余俩会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var a = 10; //window.a=10</span><br><span class="line"></span><br><span class="line">​        var a;</span><br><span class="line"></span><br><span class="line">​        console.log(a); //输出10</span><br><span class="line"></span><br><span class="line">​        var a = 20;//window.a=20</span><br><span class="line"></span><br><span class="line">​        console.log(a);//输出20</span><br><span class="line"></span><br><span class="line">​        let b;      //报错Cannot redeclare block-scoped variable &#x27;b&#x27;</span><br><span class="line"></span><br><span class="line">​        let b = 30;</span><br></pre></td></tr></table></figure><p>var的变量提升和let不同，let有暂时性死区，在作用域开始到let之前，虽然变量存在但是无法访问。会提示在初始化之前不能访问该变量。</p><h4 id="const和let关键词的异同"><a href="#const和let关键词的异同" class="headerlink" title="const和let关键词的异同"></a>const和let关键词的异同</h4><ul><li><p>二者都是块级作用域</p></li><li><p>都不能和它所在作用域内的其他变量或函数拥有相同的名称</p></li><li><p><code>const</code>声明的常量必须初始化，而<code>let</code>声明的变量不用</p></li><li><p>const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改。</p></li></ul><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>函数体内变量（私有）不会更改函数体外变量。不声明就打印就是往上级函数找变量，输出本作用域的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const a=&#x27;1&#x27;;</span><br><span class="line">​        function show()&#123;</span><br><span class="line">​            const a=&#x27;2&#x27;;</span><br><span class="line">​            function run()&#123;</span><br><span class="line">​                var a=&#x27;3&#x27;;</span><br><span class="line">​                console.log(a);</span><br><span class="line">​            &#125;</span><br><span class="line">​            run();</span><br><span class="line">​            console.log(a);</span><br><span class="line">​        &#125;</span><br><span class="line">​        show();</span><br><span class="line">​        console.log(a);</span><br></pre></td></tr></table></figure><p>后台输出 3 2 1  </p><p>变量声明没有var等关键词会导致全局污染</p><pre><code>    var a=&#39;1&#39;;    function show()&#123;        const a=&#39;2&#39;;        function run()&#123;             a=&#39;3&#39;;            console.log(a);        &#125;        run();        console.log(a);    &#125;    show();    console.log(a);</code></pre><p>结果就是3 3 3</p><p>var没有块作用域 let有 （多用于循环）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">// 这里输出 x 为 10</span><br><span class="line">&#123; </span><br><span class="line">var x = 2;</span><br><span class="line">// 这里输出 x 为 2</span><br><span class="line">&#125;</span><br><span class="line">// 这里输出 x 为 2</span><br></pre></td></tr></table></figure><p>立即执行函数控制作用域，防止对全局作用域的污染（用let或者const声明）</p><p>const多用于定义常量（在同一个作用域中不能改）引用类型和数组能改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const b = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">​        b.value=44;</span><br><span class="line"></span><br><span class="line">​        console.log(b);</span><br></pre></td></tr></table></figure><p>后台会输出{value: 44}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const b = 44;</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            const b = 22;</span><br><span class="line"></span><br><span class="line">​            console.log(b);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        console.log(b);</span><br></pre></td></tr></table></figure><p>输出 22 44 </p><h4 id="变量冻结"><a href="#变量冻结" class="headerlink" title="变量冻结"></a>变量冻结</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const Host=&#123;</span><br><span class="line"></span><br><span class="line">​            url:&quot;https://bilibili.com&quot;,</span><br><span class="line"></span><br><span class="line">​            port:886</span><br><span class="line"></span><br><span class="line">​        &#125;;</span><br><span class="line"></span><br><span class="line">​        Object.freeze(Host);</span><br><span class="line"></span><br><span class="line">​        Host.port=66;</span><br><span class="line"></span><br><span class="line">​        console.log(Host);</span><br></pre></td></tr></table></figure><p>后台输出{url: ‘<a href="https://bilibili.com/">https://bilibili.com</a>‘, port: 886}</p><p>当 Object.freeze(Host);被注释掉的时候会输出</p><p>{url: ‘<a href="https://bilibili.com/">https://bilibili.com</a>‘, port: 886}</p><p>Object.freeze（）方法可以冻结对象，在之后不可更改对象属性(冻结是浅层冻结)。</p><p>const是声明变量不可更改地址，可以更改地址中的属性。</p><h4 id="null和undefine详细"><a href="#null和undefine详细" class="headerlink" title="null和undefine详细"></a>null和undefine详细</h4><p>对于一个定义了，但未赋值的变量，系统默认其为Undefined类型，且值为undefined<br>但若一个变量连定义都没有，会出现很神奇的一幕，即使用<code>typeof操作符可检测出其类型为undefined</code>，但输出该变量值时会报错。</p><p>一般未指定指向对象的指针会被默认为Null类型，因为一个值为<code>Null的变量其实际类型为object</code>，因为系统会将其视为一个保存对象的变量，只不过还未初始化。</p><h4 id="严格模式“use-strict”"><a href="#严格模式“use-strict”" class="headerlink" title="严格模式“use strict”"></a>严格模式“use strict”</h4><p>严格模式作用域和变量基本一致，只对当前作用域和子作用域管用。</p><p>可有可无的错误会在后台报错</p><h4 id="cookie和sessionStorage和localStorage"><a href="#cookie和sessionStorage和localStorage" class="headerlink" title="cookie和sessionStorage和localStorage"></a>cookie和sessionStorage和localStorage</h4><p>cookie保存在浏览器端，session保存在服务器端！</p><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>数据生命周期</td><td>一般由服务器生成，可以设置过期时间，如果没有设置过期时间，那么在浏览器关闭时，cookie结束生命周期</td><td>关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失</td><td>在仅在当前会话下有效，关闭浏览器窗口就会被销毁。</td></tr><tr><td>数据存储大小</td><td>4kb</td><td>5MB</td><td>5MB</td></tr><tr><td>与服务端通信</td><td>保存在客户端，每次请求时都会带上它！</td><td>保存在客户端，不与服务器进行交互通信</td><td>保存在客户端，不与服务器进行交互通信</td></tr></tbody></table><h3 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a=&quot;ilikestudy&quot;</span><br><span class="line">//从左面开始查找  从右面开始查找函数为lastIndexOf 这三个函数都可指定参数，表明从第几个向前查找</span><br><span class="line">if(a.indexOf(&quot;l&quot;)!=-1)&#123; </span><br><span class="line">    console.log(&quot;找到了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(a.indexOf(&quot;l&quot;));</span><br><span class="line"></span><br><span class="line">console.log(a.includes(&quot;s&quot;)) //返回bool类型</span><br><span class="line">console.log(a.startsWith(&quot;i&quot;)) //查询开始的字符 endsWith是查询最后结尾的字符</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数值类型除了0之外都为真<br>字符串类型除了空字符串之外都为真<br>数组和对象为引用类型都为真 即使是空数组和对象[] {}</p><h3 id="如何避免失去数字精度"><a href="#如何避免失去数字精度" class="headerlink" title="如何避免失去数字精度"></a>如何避免失去数字精度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a=(0.2*100+0.1*100);</span><br><span class="line">let b=a/100;</span><br><span class="line">console.log(b); // 0.3</span><br><span class="line">let 0.1+0.2=e; //0.3000000000004</span><br><span class="line">let c=(0.2+0.1).toFixed(2)//保留两位小数 0.30</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门项目-图书管理系统</title>
      <link href="/2023/06/03/%E6%88%91%E7%9A%84%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/03/%E6%88%91%E7%9A%84%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1QU4y1E7qo/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=955be730fc7dede1925e5b4345fd551d">完整实现</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue2 </tag>
            
            <tag> element-ui </tag>
            
            <tag> egg.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/06/hello-world/"/>
      <url>/2023/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexo%E3%80%82js/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
