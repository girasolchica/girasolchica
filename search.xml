<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>零零碎碎</title>
      <link href="/2024/04/14/%E5%85%AB%E8%82%A1vue/"/>
      <url>/2024/04/14/%E5%85%AB%E8%82%A1vue/</url>
      
        <content type="html"><![CDATA[<h3 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h3><p>vue数据双向绑定是通过<code>数据劫持</code>结合<code>发布者-订阅者模式</code>的方式来实现的</p><p>我们已经知道实现数据的双向绑定，首先要对<code>数据进行劫持监听</code>，所以我们需要设置一个<code>监听器</code>Observer，用来<code>监听所有属性</code>。如果<code>属性</code>发生<code>变化</code>了，就需要<code>告诉订阅者</code>Watcher看<code>是否需要更新</code>。因为订阅者是有很多个，所以我们需要有一个<code>消息订阅器Dep</code>来专门<code>收集这些订阅者</code>，然后在<code>监听器</code>Observer和<code>订阅者</code>Watcher之间进行<code>统一管理</code>的。接着，我们还需要有一个<code>指令解析器</code>Compile，对<code>每个节点元素</code>进行<code>扫描和解析</code>，将<code>相关指令</code>（如v-model，v-on）对应<code>初始化成一个订阅者</code>Watcher，并<code>替换模板数据或者绑定相应的函数</code>，此时<code>当订阅者Watcher接收到相应属性的变化</code>，就会<code>执行对应的更新函数</code>，从而<code>更新视图</code>。</p><h3 id="组件间传递数据"><a href="#组件间传递数据" class="headerlink" title="组件间传递数据"></a>组件间传递数据</h3><p>1 父组件向子组件传递数据，使用props属性；子组件向父组件中传递数据，在子组件中使用$emit派发事件，父组件中使用v-on监听事件；<br>缺点：组件嵌套层次多的话，传递数据比较麻烦。<br>2 祖先组件通过依赖注入(inject &#x2F; provide)的方式，向其所有子孙后代传递数据；<br>缺点：无法监听数据修改的来源，不支持响应式。<br>3 通过属性$root &#x2F; $parent &#x2F; $children &#x2F;ref，访问根组件、父级组件、子组件中的数据；<br>缺点：要求组件之间要有传递性。<br>4 通过事件总线(event bus)的方式，可以实现任意两个组件间进行数据传递；<br>缺点：不支持响应式，这个概念是vue1.0版本中的，现在已经废弃。<br>5 通过 VueJs 的状态管理模式 Vuex，实现多个组件进行数据共享，推荐使用这种方式进行项目中各组件间的数据传递。</p><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>简单总结： </p><p>（1）全局函数中的this指向window</p><p>（2）对象中的方法（函数）中的this，指向对象，理解：obj.m&#x3D;function(){}，m和fn等价，因此调用m也相当于调用fn，原理同3）</p><p>（3）构造函数中的this指向调用该构造函数的实例对象</p><p>（4）特殊this指向:</p><p>箭头函数没有绑定this，this继承自外围作用域，理解：查看上一层级的函数的this的指向，继承它！！</p><p>（5）绑定this指向：apply，call，bind绑定的对象</p><h3 id="接下来用实例来介绍下各种this问题"><a href="#接下来用实例来介绍下各种this问题" class="headerlink" title="接下来用实例来介绍下各种this问题"></a>接下来用实例来介绍下各种this问题</h3><ol><li><p>全局环境下，this 始终指向全局对象（window）, 无论是否严格模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(this.document === document); // true</span><br><span class="line">// 在浏览器中，全局对象为 window 对象：</span><br><span class="line">console.log(this === window); // true</span><br><span class="line">this.a = 3;</span><br><span class="line">console.log(window.a); // 3</span><br></pre></td></tr></table></figure></li><li><p>函数直接调用，普通函数内部的this分两种情况，严格模式和非严格模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   //严格模式下， this为undefined</span><br><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; // 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line">f2() === undefined; // true</span><br><span class="line">   //而非严格模式下，this 默认指向全局对象window</span><br><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line">f1() === window; // true</span><br></pre></td></tr></table></figure></li><li><p>对象中的this，对象内部方法的this指向调用这些方法的对象</p><p>&#x2F;&#x2F;函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。<br>&#x2F;&#x2F;多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，其内部对象调<br>&#x2F;&#x2F;用方法的this指向内部对象， 而非window）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//例一：</span><br><span class="line">var obj = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.f());  //37</span><br><span class="line">var a = obj.f;</span><br><span class="line">console.log(a());  //undefined</span><br><span class="line"></span><br><span class="line">var obj = &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">  return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.f = independent;</span><br><span class="line"></span><br><span class="line">console.log(obj.f()); //37</span><br><span class="line"></span><br><span class="line">//例二：</span><br><span class="line">obj.b = &#123;</span><br><span class="line">  num: independent,</span><br><span class="line">  prop: 42</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.b.num()); //42</span><br></pre></td></tr></table></figure></li><li><p>原型链中this，原型链中的方法的this仍然指向调用它的对象</p></li></ol>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. var obj = &#123;</span><br><span class="line">     f : function()&#123; </span><br><span class="line">       return this.a + this.b; </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   var p = Object.create(obj);</span><br><span class="line">   p.a = 1;</span><br><span class="line">   p.b = 4;</span><br><span class="line"></span><br><span class="line">   console.log(p.f()); // 5</span><br><span class="line">   //在p中没有属性f，当执行p.f()时，会查找p的原型链，找到 f 函数并执行，但这与函数内部this指向对象 //p 没有任何关系，只需记住谁调用指向谁。</span><br><span class="line"></span><br><span class="line">//以上对于函数作为getter &amp; setter 调用时同样适用。</span><br></pre></td></tr></table></figure><ol start="5"><li>构造函数中this，构造函数中的this与被创建的新对象绑定</li></ol><p>注意：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。<br>6. call &amp; apply</p><p>当函数通过Function对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的this值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。<br>7. bind 方法</p><p>bind方法在ES5引入， 在Function的原型链上， Function.prototype.bind。通过bind方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。</p><ol start="8"><li>DOM事件处理函数，当函数被当做监听事件处理函数时， 其 this 指向触发该事件的元素 （针对于addEventListener事件）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被调用时，将关联的元素变成蓝色</span><br><span class="line">  function bluify(e)&#123;</span><br><span class="line">    console.log(this);//在控制台打印出所点击元素</span><br><span class="line">    e.stopPropagation();//阻止时间冒泡</span><br><span class="line">    e.preventDefault();//阻止元素的默认事件    </span><br><span class="line">    this.style.backgroundColor = &#x27;#A5D9F3&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  var elements = document.getElementsByTagName(&#x27;*&#x27;);// 获取文档中的所有元素的列表</span><br><span class="line">  // 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line">  for(var i=0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">    elements[i].addEventListener(&#x27;click&#x27;, bluify, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>内联事件，内联事件中的this指向分两种情况：</li></ol><p>当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素<br>当代码被包括在函数内部执行时，其this指向等同于函数直接调用的情况，即在非严格模式指向全局对象window， 在严格模式指向undefined。<br>10. setTimeout &amp; setInterval，对于延时函数内部的回调函数的this指向全局对象window（当然我们可以通过bind方法改变其内部函数的this指向） </p><pre><code>//默认情况下function Person() &#123;      this.age = 0;      setTimeout(function() &#123;        console.log(this);    &#125;, 3000);&#125;//通过bind绑定function Person() &#123;      this.age = 0;      setTimeout((function() &#123;        console.log(this);    &#125;).bind(this), 3000);&#125;var p = new Person();//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</code></pre><ol start="11"><li><p>箭头函数中的 this，由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值 </p><p>&#x2F;&#x2F; call() &#x2F; apply() &#x2F; bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。<br>&#x2F;&#x2F;考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。（可以忽略是否在严格<br>&#x2F;&#x2F;模式下的影响）<br>&#x2F;&#x2F;因为箭头函数可以捕获其所在上下文的this值 所以:<br>function Person() {<br>this.age &#x3D; 0;<br>setInterval(() &#x3D;&gt; {<br>    this.age++;&#x2F;&#x2F; 回调里面的 <code>this</code> 变量就指向了期望的那个对象了<br>}, 3000);<br>}<br>var p &#x3D; new Person();<br>​&#x2F;&#x2F;以上代码可以得到我们所以希望的值，下图可以看到，在setTimeout中的this指向了构造函数新生成</p></li></ol><p>​    &#x2F;&#x2F;的对象，而普通函数指向了全局window对象</p><h3 id="二、Vue中的this"><a href="#二、Vue中的this" class="headerlink" title="二、Vue中的this"></a>二、Vue中的this</h3><ol><li>Vue methods</li></ol><p>来看看官方文档给出的解释：</p><p>methods 将被混入到 Vue 实例中。可以直接通过 实例vm 访问这些方法，或者在指令表达式中使用。方法中的 this自动绑定为 Vue 实例（vm）。</p><p>注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () &#x3D;&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。</p><p>长话短说，官方的意思是：在Vue实例中，methods中如果用的是正常函数，那么它的this就指向Vue实例；如果是箭头函数，this就指向window对象；</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>Vue methods 中不应该箭头函数定义methods函数，因为箭头函数绑定了父级作用域上下文，所以 this 打印出的结果是Window 对象；不使用箭头函数的情况下，this 实际上是指向了一个 Proxy 对象。</p><p>原因是vue 内部实际上对methods属性中的方法进行了遍历，将对应的方法通过bind绑定了this，使得this指向实例vm</p><ol start="2"><li>Vue中生命周期钩子和自定义方法中的this指向当前的 Vue 实例</li></ol><p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () &#x3D;&gt; this.checkTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.checkTodos 的行为未定义。</p><ol start="3"><li>Vue 中回调函数中的 this：</li></ol><p>若回调函数为匿名函数，非严格模式下指向 window,严格模式下为 undefined。<br>若回调函数为自定义方法，则 this 指向 Vue 实例。<br>若回调函数为 箭头函数，则 this 指向 Vue 实例。<br>4. Vue 中 addEventListener 中的 this</p><p>通常，事件监听函数中的 this 都指向绑定事件的那个元素, 但是在 Vue 中，监听函数中的 this 也指向 Vue 实例</p><ol start="5"><li>在data里定义Object类型的变量时的this</li></ol><p>在data里定义Object类型的变量时，会发现Object中访问不到vue的this属性，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      a: &quot;123&quot;,</span><br><span class="line">      b: &#123;</span><br><span class="line">        c: this.a</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&quot;b: &quot;, this.b.c); // undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想在b中访问this.a的数据，直接访问会返回undefined，因为这时c中的this指向的是b。这种情况可以用到Object的get属性进行属性定义，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      a: &quot;123&quot;,</span><br><span class="line">      b: &#123;</span><br><span class="line">        _target: () =&gt; this,</span><br><span class="line">        get target() &#123;</span><br><span class="line">          return this._target();</span><br><span class="line">        &#125;,</span><br><span class="line">        get c() &#123;</span><br><span class="line">          return this.target.a;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&quot;b: &quot;, this.b.c); // 123</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处将this映射到了Object变量内部，然后通过get的形式定义属性并获取，这样就解决问题啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零零碎碎</title>
      <link href="/2024/04/14/%E5%85%AB%E8%82%A1css/"/>
      <url>/2024/04/14/%E5%85%AB%E8%82%A1css/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS-单位中-px、em-和-rem-的区别？"><a href="#CSS-单位中-px、em-和-rem-的区别？" class="headerlink" title="CSS 单位中 px、em 和 rem 的区别？"></a>CSS 单位中 px、em 和 rem 的区别？</h3><p>一、px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</p><p>二、em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。</p><p>三、em是相对于其父元素来设置字体大小的，一般都是以的“font-size”为基准。这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值</p><p>总之：对于em和rem的区别一句话概括：</p><p>em相对于父元素，rem相对于根元素。</p><h3 id="水平垂直居中的几种方法"><a href="#水平垂直居中的几种方法" class="headerlink" title="水平垂直居中的几种方法"></a>水平垂直居中的几种方法</h3><p>1 使用flex布局<br>利用flex的alignItems:center垂直居中，justifycontent:center水平居中<br>2 利用相对定位和绝对定位的margin:auto<br>相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中<br>3 利用相对定位和绝对定位，再加上外边距和平移的配合<br>相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可</p><p>4 利用textAlign和verticalAlign<br>利用textAlign:center实现行内元素的水平居中，再利用verticalAlign:middle实现行内元素的垂直居中，前提是要先加上伪元素并给设置高度为100%，用过elementUI的可以去看看其消息弹窗居中实现方式就是如此</p><p>5 其他<br>上面都是在未知外容器和自身宽高下实现水平垂直居中的，如果已知其宽高，可以有更多种简单的方式实现居中，其原理无非是利用绝对定位的top&#x2F;left偏移、margin偏移、padding填充，在此就不分析了。还有就是单纯文字的居中利用lineHeight和textAlign即可实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零零碎碎</title>
      <link href="/2024/04/03/%E5%85%AB%E8%82%A1html/"/>
      <url>/2024/04/03/%E5%85%AB%E8%82%A1html/</url>
      
        <content type="html"><![CDATA[<h3 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h3><ol><li>应用标签不同<br><strong>src</strong>属性的作用是<strong>指定要加载的资源路径</strong>，常出现于<code>&lt;script&gt;</code> 、<code>&lt;cimage&gt;</code> 、 <code>&lt;audio&gt;</code> 、<code>&lt;video&gt;</code>和<code>&lt;ciframe&gt;</code>等标签中，用于加载JavaScript脚本、图像、音频、视频或嵌入的网页文件。<br><strong>href</strong>属性的作用是<strong>指定超链接的目标地址</strong>或<strong>定义文档与外部资源的关联</strong>，主要用在<code>&lt;a&gt;</code> 、<code>&lt;clink&gt;</code> 、 <code>&lt;area&gt;</code>等标签中。例如，当你创建一个超链接<code>&lt;a&gt;</code>时，需要用href属性指定用户点击后跳转的目标URL;或者当你在文档头部使用<code>&lt;link&gt;</code>标签引入外部样式表时，也是使用href属性来指定样式表的地址。</li><li>资源加载方式不同<br>当浏览器解析到适用于<strong>src属性</strong>的标签（比如<code>&lt;script&gt;</code>和<code>&lt;img&gt;</code>）时，会<strong>暂停其他资源的下载和处理</strong>，直到将该资源<strong>加载</strong>、<strong>编译</strong>(如果是JavaScript)、<strong>执行</strong>（如果是脚本）完成。这种方式称为<strong>阻塞加载</strong>，所以<code>一般建议将JavaScript脚本放在页面底部</code>。而当浏览器识别到适用于<strong>href</strong>属性的标签(比如<code>&lt;a&gt;</code>和<code>&lt;clink&gt;</code>)时，会<code>并行下载资源</code>，不会停止对当前文档的处理。这种方式称为<code>非阻塞加载</code>，浏览器可以同时处理超链接或引入样式表。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情景题</title>
      <link href="/2024/03/26/%E6%83%85%E6%99%AF%E9%A2%98/"/>
      <url>/2024/03/26/%E6%83%85%E6%99%AF%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器从URL输出到页面加载的全过程"><a href="#浏览器从URL输出到页面加载的全过程" class="headerlink" title="浏览器从URL输出到页面加载的全过程"></a>浏览器从URL输出到页面加载的全过程</h3><p>1 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP ，向服务器发起请求；</p><p>2 服务器交给后台处理完成后返回数据，浏览器接收⽂件（ HTML、JS、CSS 、图象等）；</p><p>3 浏览器对加载到的资源（ HTML、JS、CSS 等）进⾏语法解析，建立相应的内部数据结构 （如 HTML 的 DOM）；</p><p>4 载⼊解析到的资源⽂件，渲染页面，完成。<br>————————————————</p><p>客户端网址中输入url<br>将输入的url发送到DNS获得该域名对应的WEB服务器的ip地址<br>客户端游览器与WEB服务器建立TCP连接<br>客户端游览器向WEB服务器发送HTTP或HTTPS请求<br>WEB服务器响应请求，返回指定的URL数据或错误信息<br>客户端拿到WEB服务器的数据后解析源文件，进行页面排版，显示基础页面<br>分析页面中的超链接，渲染页面<br>————————————————</p><p>————————————————<br>浏览器地址栏输入url地址，首先要在客户端上进行url解析<br>浏览器会首先查看自身的缓存，如果浏览器缓存中有对应的解析记录，直接返回结果<br>如果浏览器没有缓存，电脑会查看本地操作系统的缓存，如果有记录，直接返回结果（host文件）<br>如果本地没有缓存该域名的IP地址，就需要通过递归或迭代的方式向根域名服务器、顶级域名服务器、权威域名服务器发起查询请求，直至返回一个IP地址给浏览器。<br>然后根据该IP地址建立TCP连接。<br>客户端发送HTTP请求，服务器返回报文，关闭TCP连接。<br>浏览器内核拿到相应内容后，<br>解析html,css分别建立DOM Tree和CSSOM Tree<br>随后这两个合并成Render Tree。<br>然后布局Render Tree，绘制Render Tree，绘制页面像素信息。<br>浏览器会将各层的信息发送给GPU,GPU会将各层合成，显示在屏幕上。<br>渲染完成。<br>————————————————<br>详细简版：<br>1 从浏览器接收 url 到开启⽹络请求线程（这⼀部分可以展开浏览器的机制以及进程与线程 之间的关系）</p><p>2 开启⽹络线程到发出⼀个完整的 HTTP 请求（这⼀部分涉及到dns查询， TCP&#x2F;IP 请求，五层因特⽹协议栈等知识）</p><p>3 从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</p><p>4 后台和前台的 HTTP 交互（这⼀部分包括 HTTP 头部、响应码、报⽂结构、 cookie 等知 识，可以提下静态资源 的 cookie 优化，以及编码解码，如 gzip 压缩等）</p><p>6 单独拎出来的缓存问题， HTTP 的缓存（这部分包括http缓存头部， ETag ， catchcontrol 等）<br>浏览器接收到 HTTP 数据包后的解析流程（解析 html、 词法分析然后解析成 dom 树、解析 css ⽣成 css 规则树、合并成 render 树，然后 layout 、 painting 渲染、复合图层的合成、 GPU 绘制、外链资源的处理、 loaded 和 DOMContentLoaded 等）</p><p>7 CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框， BFC ， IFC 等概念）<br>JS 引擎解析过程（ JS 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， VO ，作 ⽤域链、回收机制等等）</p><p>8 其它（可以拓展不同的知识模块，如跨域，web安全， hybrid 模式等等内容）</p><h3 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h3><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。<br>整个渲染流程分为多个阶段，分别是：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><h4 id="渲染的第一步是解析-HTML。"><a href="#渲染的第一步是解析-HTML。" class="headerlink" title="渲染的第一步是解析 HTML。"></a>渲染的第一步是解析 HTML。</h4><p>解析过程中遇到 CSS 解析 CSS, 遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。<br>如果主线程解析到 Link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。<br>如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。<br>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><h4 id="渲染的下一步是样式计算。"><a href="#渲染的下一步是样式计算。" class="headerlink" title="渲染的下一步是样式计算。"></a>渲染的下一步是样式计算。</h4><p>主线程会遍历得到的DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style.在这一过程中，很多预设值会变成绝对值，比如 red 会变成 rgb(255, 0, 0)；相对单位会变成绝对单位，比如 em 会变成 px<br>这一步完成后，会得到一棵带有样式的 DOM 树。</p><h4 id="接下来是布局，布局完成后会得到布局树。"><a href="#接下来是布局，布局完成后会得到布局树。" class="headerlink" title="接下来是布局，布局完成后会得到布局树。"></a>接下来是布局，布局完成后会得到布局树。</h4><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。<br>大部分时候，DOM 树和布局树并非——对应。<br>比如 display:none 的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法——对应。</p><h4 id="下一步是分层"><a href="#下一步是分层" class="headerlink" title="下一步是分层"></a>下一步是分层</h4><p>主线程会使用一套复杂的策略对整个布局树中进行分层。<br>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。<br>滚动条、堆叠上下文、transform. opacity 等样式都会或多或少的影的分层结果，也可以通过will-change 属性更大程度的影响分层结果。</p><h4 id="再下一步是绘制"><a href="#再下一步是绘制" class="headerlink" title="再下一步是绘制"></a>再下一步是绘制</h4><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。<br>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。<br>它会从线程池中拿取多个线程来完成分块工作。</p><h4 id="分块完成后，进入光栅化阶段。"><a href="#分块完成后，进入光栅化阶段。" class="headerlink" title="分块完成后，进入光栅化阶段。"></a>分块完成后，进入光栅化阶段。</h4><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。<br>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块<br>光栅化的结果，就是一块一块的位图</p><h4 id="最后一个阶段就是画了"><a href="#最后一个阶段就是画了" class="headerlink" title="最后一个阶段就是画了"></a>最后一个阶段就是画了</h4><p>教言<br>合成线程拿到每个层、每个块的位图后，生成一个个「指引(quad)」信息。<br>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。<br>变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。<br>ation<br>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h3 id="什么是-reflow"><a href="#什么是-reflow" class="headerlink" title="什么是 reflow?"></a>什么是 reflow?</h3><p><strong>reflow 的本质就是重新计算 layout 树。</strong><br>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。<br>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。<br>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。I 浏览器在反复权衡下，最终决定获取属性立即 reflow.</p><p>回流（reflow）：当render tree中的元素的宽高、布局、显示、隐藏或元素内部文字结结构发生改变时，会影响自身及其父元素、甚至追溯到更多的祖先元素发生改变，则会导致元素内部、周围甚至整个页面的重新渲染，页面发生重构，回流就产生了。</p><h3 id="什么是-repaint"><a href="#什么是-repaint" class="headerlink" title="什么是 repaint?"></a>什么是 repaint?</h3><p><strong>repaint 的本质就是重新根据分层信息计算了绘制指令。</strong>当改动了可见样式后，就需要重新计算，会引发 repaint。<br>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><p>重绘（repaint）：元素的结构（宽高、布局、显示隐藏、内部文字大小）未发生改变，只是元素的外观样式发生改变，比如背景颜色、内部文字颜色、边框颜色等。此时会引起浏览器重绘，显然重绘的速度快于回流。</p><p>回流一定会触发重绘，重绘不一定触发回流。</p><p>4.为什么 transform 的效率高?<br>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个 「draw」 阶段由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>切换不同环境的api</title>
      <link href="/2023/12/26/%E5%BC%80%E5%8F%91%E5%88%87%E6%8D%A2api/"/>
      <url>/2023/12/26/%E5%BC%80%E5%8F%91%E5%88%87%E6%8D%A2api/</url>
      
        <content type="html"><![CDATA[<h3 id="request-js中关于api的切换的内容"><a href="#request-js中关于api的切换的内容" class="headerlink" title="request.js中关于api的切换的内容"></a>request.js中关于api的切换的内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function request(options) &#123;</span><br><span class="line">  options.method = options.method || &quot;get&quot;;</span><br><span class="line">  //关于get请求参数调整</span><br><span class="line">  if (options.method.toLowerCase() === &quot;get&quot;) &#123;</span><br><span class="line">    options.params = options.data;</span><br><span class="line">  &#125;</span><br><span class="line">  //对mock开关进行处理</span><br><span class="line">  let isMock = config.mock;</span><br><span class="line">  </span><br><span class="line">  if (typeof options.isMock !== &quot;undefined&quot;) &#123;//确保传入</span><br><span class="line">    isMock = options.mock;</span><br><span class="line">  &#125;</span><br><span class="line">  //针对环境进行处理</span><br><span class="line">  if (config.env === &#x27;prod&#x27;) &#123;</span><br><span class="line">    service.defaults.baseURL = config.baseApi;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    service.defaults.baseURL = isMock ? config.mockApi : config.baseApi;</span><br><span class="line">  &#125;</span><br><span class="line">  return service(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="config-js内容"><a href="#config-js内容" class="headerlink" title="config.js内容"></a>config.js内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const env = import.meta.env.MODE || &quot;prod&quot;; </span><br><span class="line">const EnvConfig = &#123;</span><br><span class="line">  development: &#123;  //开发板</span><br><span class="line">    baseApi: &#x27;api&#x27;,//本地的api文件内容</span><br><span class="line">    mockApi: &quot;https://apifoxmock.com/m1/4068509-0-default/api&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  test: &#123;   // 测试版</span><br><span class="line">    baseApi: &#x27;//test.future.com/api&#x27;,</span><br><span class="line">    mockApi: &quot;https://apifoxmock.com/m1/4068509-0-default/api&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  prod: &#123; //上线版</span><br><span class="line">    baseApi: &#x27;//future.com/api&#x27;,</span><br><span class="line">    mockApi: &quot;https://apifoxmock.com/m1/4068509-0-default/api&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">export default &#123;</span><br><span class="line">  env,</span><br><span class="line">  ...EnvConfig[env],</span><br><span class="line">  //mock</span><br><span class="line">  mock:false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getTableData() &#123;</span><br><span class="line">    return request(&#123;</span><br><span class="line">      url: &quot;/home/getTableData&quot;,</span><br><span class="line">      method: &quot;get&quot;,</span><br><span class="line">      // mock:false, //单独管理数据来源</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全景图基础</title>
      <link href="/2023/08/14/photo-sphere-viewer%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
      <url>/2023/08/14/photo-sphere-viewer%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="photo-sphere-viewer中文文档"><a href="#photo-sphere-viewer中文文档" class="headerlink" title="photo-sphere-viewer中文文档"></a>photo-sphere-viewer中文文档</h3><p><a href="https://chenjianhong.blog.csdn.net/article/details/122243459?spm=1001.2014.3001.5502">https://chenjianhong.blog.csdn.net/article/details/122243459?spm=1001.2014.3001.5502</a></p><h3 id="博客上传时遇到443问题"><a href="#博客上传时遇到443问题" class="headerlink" title="博客上传时遇到443问题"></a>博客上传时遇到443问题</h3><p>可以通过关闭防火墙解决</p>]]></content>
      
      
      
        <tags>
            
            <tag> photo-sphere-viewer组件 </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础2</title>
      <link href="/2023/06/13/v-if%E4%B8%8Ev-show/"/>
      <url>/2023/06/13/v-if%E4%B8%8Ev-show/</url>
      
        <content type="html"><![CDATA[<h3 id="v-if与v-show"><a href="#v-if与v-show" class="headerlink" title="v-if与v-show"></a>v-if与v-show</h3><p>v-show会把元素css改变（display：none），主用于频繁显示隐藏，（对性能要求高可以用。）</p><p>v-if会把元素变成注释节点，操作dom</p><p>ref和relactive可以把值变成响应式的</p><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>NaN全称是Not a Number就是元素不是数字类型</p><p>NaN与<strong>任何值</strong>相加都会得到NaN</p><p>与任何值都不相等</p><p>isNaN()：<code>会先尝试转换为数字</code>，若无法转换为数字，就返回true，否则返回false</p><p>Number.isNaN():直接检查元素是不是NaN</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          console.log(NaN===NaN);//false</span><br><span class="line">          </span><br><span class="line">          console.log(isNaN(5));//false</span><br><span class="line"></span><br><span class="line">​            console.log(isNaN(&#x27;5&#x27;));//false</span><br><span class="line"></span><br><span class="line">​            console.log(isNaN(&#x27;apple&#x27;));//true</span><br><span class="line"></span><br><span class="line">​            console.log(Number.isNaN(NaN));//true</span><br><span class="line"></span><br><span class="line">​            console.log(Number.isNaN(5));//false</span><br><span class="line"></span><br><span class="line">​            console.log(Number.isNaN(&#x27;5&#x27;));//false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符与关键词</title>
      <link href="/2023/06/11/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
      <url>/2023/06/11/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="运算符“-”和“-”异同"><a href="#运算符“-”和“-”异同" class="headerlink" title="运算符“&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”异同"></a>运算符“&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”异同</h3><p>“&#x3D;&#x3D;”是比较运算符，计算机可以帮助转换成同类型的进行比较。</p><p>“&#x3D;&#x3D;&#x3D;”（全等于&#x2F;绝对等于）也是比较运算符，但是计算机不会帮助进行类型转换。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        let a=6;    //typeof Number</span><br><span class="line">        let c=&#x27;6&#x27;;  //typeof String</span><br><span class="line"></span><br><span class="line">​        console.log(a==c);  //true</span><br><span class="line"></span><br><span class="line">​        console.log(a === c);   //false</span><br></pre></td></tr></table></figure><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>首先设置表达式 <em>n</em>（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较。如果存在匹配，则与该 case 关联的代码块会被执行。请使用 <strong>break</strong> 来阻止代码自动地向下一个 case 运行。如果都没有break，那么就会把case语句中都执行然后到default再退出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        switch (n) &#123;</span><br><span class="line"></span><br><span class="line">​                case 1:</span><br><span class="line"></span><br><span class="line">​        执行代码块 1</span><br><span class="line"></span><br><span class="line">​                    break;</span><br><span class="line"></span><br><span class="line">​                case 2:</span><br><span class="line"></span><br><span class="line">​        执行代码块 2</span><br><span class="line"></span><br><span class="line">​                    break;</span><br><span class="line"></span><br><span class="line">​                default:</span><br><span class="line"></span><br><span class="line">​        与 case 1 和 case 2 不同时执行的代码</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br></pre></td></tr></table></figure><p>while 循环会在指定条件为真时循环执行代码块。</p><p>do&#x2F;while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。该循环至少会执行一次，即使条件为 false 它也会执行一次，因为代码块会在条件被测试前执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function star(row = 5) &#123;</span><br><span class="line"></span><br><span class="line">​            let start = 0;</span><br><span class="line"></span><br><span class="line">​            do &#123;</span><br><span class="line"></span><br><span class="line">​                let n = 0;</span><br><span class="line"></span><br><span class="line">​                do &#123;</span><br><span class="line"></span><br><span class="line">​                    document.write(&#x27;*&#x27;);</span><br><span class="line"></span><br><span class="line">​                &#125; while (++n &lt;= start);</span><br><span class="line"></span><br><span class="line">​                document.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line"></span><br><span class="line">​            &#125; while (++start &lt;= row);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        star();</span><br></pre></td></tr></table></figure><p>for循环打印杨辉三角</p><p><img src="/../img/sanjiao.jpg" alt="杨辉三角"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function sanjiao(row = 5) &#123;</span><br><span class="line"></span><br><span class="line">​            for (let i = 1; i &lt; row; i++) &#123; //控制行数</span><br><span class="line"></span><br><span class="line">​                for (let n = row - i; n &gt; 0; n--) &#123;</span><br><span class="line"></span><br><span class="line">​                    document.write(&quot;^&quot;);//先打印出空白区域</span><br><span class="line"></span><br><span class="line">​                &#125;</span><br><span class="line"></span><br><span class="line">​                for (let m = i * 2 - 1; m &gt; 0; m--) &#123;</span><br><span class="line"></span><br><span class="line">​                    document.write(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">​                &#125;</span><br><span class="line"></span><br><span class="line">​                document.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        sanjiao(5);</span><br></pre></td></tr></table></figure><h3 id="typeof与instancesof"><a href="#typeof与instancesof" class="headerlink" title="typeof与instancesof"></a>typeof与instancesof</h3><p>instanceof能够详细区分数组属性和对象属性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            let arr=[];</span><br><span class="line"></span><br><span class="line">​            console.log(typeof arr); //object</span><br><span class="line"></span><br><span class="line">​            let a=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">​            console.log(typeof a);//object</span><br><span class="line"></span><br><span class="line">​            console.log(arr instanceof Array);//判断arr.prototype(原型链上是否有数组属性) 会打印true</span><br><span class="line"></span><br><span class="line">​            console.log(a instanceof Object);//判断a.peototype  true</span><br></pre></td></tr></table></figure><p>\为转义符号，可以更改符号的意义使其正常输出。</p><h3 id="字符串的连接"><a href="#字符串的连接" class="headerlink" title="字符串的连接"></a>字符串的连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let year=&quot;2008&quot;;</span><br><span class="line">let month=&quot;11&quot;;</span><br><span class="line">let su= `$&#123;year&#125;年$&#123;month&#125;是很难忘的日期`;</span><br><span class="line">console.log(year+&quot;年&quot;+month+&quot;是很难忘的日期&quot;);</span><br><span class="line"></span><br><span class="line">console.log(`$&#123;year&#125;年$&#123;month&#125;是很难忘的日期`);</span><br><span class="line"></span><br><span class="line">console.log(su);</span><br></pre></td></tr></table></figure><p>输出结果一致，更推荐使用第二种。即使用··进行字符串的连接。</p><h3 id="封装获取日期函数"><a href="#封装获取日期函数" class="headerlink" title="封装获取日期函数"></a>封装获取日期函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const date = new Date();</span><br><span class="line"></span><br><span class="line">function dateFormat(date,format=&quot;YYYY-MM-DD hh:mm:ss&quot;)&#123;</span><br><span class="line">        const config=&#123;</span><br><span class="line">                YYYY:date.getFullYear();</span><br><span class="line">                MM:date.getMonth() + 1;// 月份从0开始，需要加1</span><br><span class="line">                DD:date.getDate();</span><br><span class="line">                hh:date.getHours();</span><br><span class="line">                mm:date.getMinutes();</span><br><span class="line">                ss:date.getSeconds();</span><br><span class="line">        &#125;;</span><br><span class="line">        for(const key in config)&#123;</span><br><span class="line">                format=format.replace(key,config[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        return format;</span><br><span class="line">&#125;</span><br><span class="line">console.log(dateFormat(date,&#x27;YYYY年MM月DD日&#x27;));//后面可以更改格式，否则是上方的默认格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础</title>
      <link href="/2023/06/10/js%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/06/10/js%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="javascript变量的生命周期"><a href="#javascript变量的生命周期" class="headerlink" title="javascript变量的生命周期"></a>javascript变量的生命周期</h4><p>JavaScript 变量生命周期在它声明时初始化。</p><p>局部变量在函数执行完毕后销毁。</p><p>全局变量在页面关闭后销毁。</p><p>var会污染window变量。</p><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>由于var定义变量会有变量提升（声明会提升但是不会提升初始化赋值），因此let和const定义变量比较好。</p><p>var支持先使用再赋值。剩余两者必须先声明再使用（很好的习惯）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        console.log(a);</span><br><span class="line">​        var a = &#x27;111&#x27;;</span><br></pre></td></tr></table></figure><p>后台提示undefined。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            console.log(a);</span><br><span class="line">​            let a = &#x27;111&#x27;;</span><br></pre></td></tr></table></figure><p>后台提示Uncaught ReferenceError: Cannot access ‘a’ before initialization</p><p>下面例子表明先声明再使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function sun(a=b,b=3)&#123;&#125;</span><br><span class="line">​        sun();</span><br></pre></td></tr></table></figure><p>后台提示ReferenceError: Cannot access ‘b’ before initialization</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function sun(a=3,b=a)&#123;&#125;</span><br><span class="line">​        sun();</span><br></pre></td></tr></table></figure><p>此时a&#x3D;b&#x3D;3</p><h4 id="var和let的区别"><a href="#var和let的区别" class="headerlink" title="var和let的区别"></a>var和let的区别</h4><p>全局作用域下var定义的变量会被挂载到window上，let不会被挂载到window上。</p><p>var没块级作用域，let有。</p><p>var可以重复声明（相当于window上的对象进行重新赋值），剩余俩会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var a = 10; //window.a=10</span><br><span class="line"></span><br><span class="line">​        var a;</span><br><span class="line"></span><br><span class="line">​        console.log(a); //输出10</span><br><span class="line"></span><br><span class="line">​        var a = 20;//window.a=20</span><br><span class="line"></span><br><span class="line">​        console.log(a);//输出20</span><br><span class="line"></span><br><span class="line">​        let b;      //报错Cannot redeclare block-scoped variable &#x27;b&#x27;</span><br><span class="line"></span><br><span class="line">​        let b = 30;</span><br></pre></td></tr></table></figure><p>var的变量提升和let不同，let有暂时性死区，在作用域开始到let之前，虽然变量存在但是无法访问。会提示在初始化之前不能访问该变量。</p><h4 id="const和let关键词的异同"><a href="#const和let关键词的异同" class="headerlink" title="const和let关键词的异同"></a>const和let关键词的异同</h4><ul><li><p>二者都是块级作用域</p></li><li><p>都不能和它所在作用域内的其他变量或函数拥有相同的名称</p></li><li><p><code>const</code>声明的常量必须初始化，而<code>let</code>声明的变量不用</p></li><li><p>const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改。</p></li></ul><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>函数体内变量（私有）不会更改函数体外变量。不声明就打印就是往上级函数找变量，输出本作用域的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const a=&#x27;1&#x27;;</span><br><span class="line">​        function show()&#123;</span><br><span class="line">​            const a=&#x27;2&#x27;;</span><br><span class="line">​            function run()&#123;</span><br><span class="line">​                var a=&#x27;3&#x27;;</span><br><span class="line">​                console.log(a);</span><br><span class="line">​            &#125;</span><br><span class="line">​            run();</span><br><span class="line">​            console.log(a);</span><br><span class="line">​        &#125;</span><br><span class="line">​        show();</span><br><span class="line">​        console.log(a);</span><br></pre></td></tr></table></figure><p>后台输出 3 2 1  </p><p>变量声明没有var等关键词会导致全局污染</p><pre><code>    var a=&#39;1&#39;;    function show()&#123;        const a=&#39;2&#39;;        function run()&#123;             a=&#39;3&#39;;            console.log(a);        &#125;        run();        console.log(a);    &#125;    show();    console.log(a);</code></pre><p>结果就是3 3 3</p><p>var没有块作用域 let有 （多用于循环）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">// 这里输出 x 为 10</span><br><span class="line">&#123; </span><br><span class="line">var x = 2;</span><br><span class="line">// 这里输出 x 为 2</span><br><span class="line">&#125;</span><br><span class="line">// 这里输出 x 为 2</span><br></pre></td></tr></table></figure><p>立即执行函数控制作用域，防止对全局作用域的污染（用let或者const声明）</p><p>const多用于定义常量（在同一个作用域中不能改）引用类型和数组能改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const b = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">​        b.value=44;</span><br><span class="line"></span><br><span class="line">​        console.log(b);</span><br></pre></td></tr></table></figure><p>后台会输出{value: 44}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const b = 44;</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            const b = 22;</span><br><span class="line"></span><br><span class="line">​            console.log(b);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        console.log(b);</span><br></pre></td></tr></table></figure><p>输出 22 44 </p><h4 id="变量冻结"><a href="#变量冻结" class="headerlink" title="变量冻结"></a>变量冻结</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const Host=&#123;</span><br><span class="line"></span><br><span class="line">​            url:&quot;https://bilibili.com&quot;,</span><br><span class="line"></span><br><span class="line">​            port:886</span><br><span class="line"></span><br><span class="line">​        &#125;;</span><br><span class="line"></span><br><span class="line">​        Object.freeze(Host);</span><br><span class="line"></span><br><span class="line">​        Host.port=66;</span><br><span class="line"></span><br><span class="line">​        console.log(Host);</span><br></pre></td></tr></table></figure><p>后台输出{url: ‘<a href="https://bilibili.com/">https://bilibili.com</a>‘, port: 886}</p><p>当 Object.freeze(Host);被注释掉的时候会输出</p><p>{url: ‘<a href="https://bilibili.com/">https://bilibili.com</a>‘, port: 886}</p><p>Object.freeze（）方法可以冻结对象，在之后不可更改对象属性(冻结是浅层冻结)。</p><p>const是声明变量不可更改地址，可以更改地址中的属性。</p><h4 id="null和undefine详细"><a href="#null和undefine详细" class="headerlink" title="null和undefine详细"></a>null和undefine详细</h4><p>对于一个定义了，但未赋值的变量，系统默认其为Undefined类型，且值为undefined<br>但若一个变量连定义都没有，会出现很神奇的一幕，即使用typeof操作符可检测出其类型为undefined，但输出该变量值时会报错。</p><p>一般未指定指向对象的指针会被默认为Null类型，因为一个值为Null的变量其实际类型为object，因为系统会将其视为一个保存对象的变量，只不过还未初始化。</p><h4 id="严格模式“use-strict”"><a href="#严格模式“use-strict”" class="headerlink" title="严格模式“use strict”"></a>严格模式“use strict”</h4><p>严格模式作用域和变量基本一致，只对当前作用域和子作用域管用。</p><p>可有可无的错误会在后台报错</p><h4 id="cookie和sessionStorage和localStorage"><a href="#cookie和sessionStorage和localStorage" class="headerlink" title="cookie和sessionStorage和localStorage"></a>cookie和sessionStorage和localStorage</h4><p>cookie保存在浏览器端，session保存在服务器端！</p><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>数据生命周期</td><td>一般由服务器生成，可以设置过期时间，如果没有设置过期时间，那么在浏览器关闭时，cookie结束生命周期</td><td>关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失</td><td>在仅在当前会话下有效，关闭浏览器窗口就会被销毁。</td></tr><tr><td>数据存储大小</td><td>4kb</td><td>5MB</td><td>5MB</td></tr><tr><td>与服务端通信</td><td>保存在客户端，每次请求时都会带上它！</td><td>保存在客户端，不与服务器进行交互通信</td><td>保存在客户端，不与服务器进行交互通信</td></tr></tbody></table><h3 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a=&quot;ilikestudy&quot;</span><br><span class="line">//从左面开始查找  从右面开始查找函数为lastIndexOf 这三个函数都可指定参数，表明从第几个向前查找</span><br><span class="line">if(a.indexOf(&quot;l&quot;)!=-1)&#123; </span><br><span class="line">    console.log(&quot;找到了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(a.indexOf(&quot;l&quot;));</span><br><span class="line"></span><br><span class="line">console.log(a.includes(&quot;s&quot;)) //返回bool类型</span><br><span class="line">console.log(a.startsWith(&quot;i&quot;)) //查询开始的字符 endsWith是查询最后结尾的字符</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数值类型除了0之外都为真<br>字符串类型除了空字符串之外都为真<br>数组和对象为引用类型都为真 即使是空数组和对象[] {}</p><h3 id="如何避免失去数字精度"><a href="#如何避免失去数字精度" class="headerlink" title="如何避免失去数字精度"></a>如何避免失去数字精度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a=(0.2*100+0.1*100);</span><br><span class="line">let b=a/100;</span><br><span class="line">console.log(b); // 0.3</span><br><span class="line"></span><br><span class="line">let c=(0.2+0.1).toFixed(2)//保留两位小数 0.30</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门项目-图书管理系统</title>
      <link href="/2023/06/03/%E6%88%91%E7%9A%84%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/03/%E6%88%91%E7%9A%84%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1QU4y1E7qo/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=955be730fc7dede1925e5b4345fd551d">完整实现</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue2 </tag>
            
            <tag> element-ui </tag>
            
            <tag> egg.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/06/hello-world/"/>
      <url>/2023/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexo%E3%80%82js/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
